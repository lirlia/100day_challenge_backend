# Day34 - B+Tree Based Simple DB

## 1. 目的

このプロジェクトの目的は、リレーショナルデータベースマネジメントシステム (RDBMS) のコアコンポーネントであるストレージエンジン、特に **B+Tree** インデックス構造の基本的な実装を通じて、データベース内部のデータ格納とアクセス方法への理解を深めることです。また、SQLパーサーと自作ストレージエンジンを連携させる基本的な流れを体験し、将来的なトランザクション機能の導入を見据えた基礎設計を行うことも目的とします。

## 2. 主要機能

### 2.1 コア機能

-   **テーブル作成:**
    -   単純な `CREATE TABLE table_name (id INTEGER PRIMARY KEY, column1 TEXT, column2 INTEGER)` 形式のSQLをサポートします。
    -   主キーは `id` という名前の INTEGER 型で、自動的にB+Treeのキーとして使用されます。
    -   テーブル定義（スキーマ情報）はメモリ上に保持します。
-   **データ挿入:**
    -   `INSERT INTO table_name (id, column1, ...) VALUES (?, ?, ...)` 形式のSQLをサポートします。
    -   指定された `id` をキー、他のカラムデータをシリアライズしたものをバリューとしてB+Treeに格納します。
-   **データ検索 (主キー):**
    -   `SELECT column1, column2 FROM table_name WHERE id = ?` 形式のSQLをサポートします。
    -   B+Treeを検索し、該当するキーのバリューをデシリアライズして返します。
-   **データ削除 (主キー):**
    -   `DELETE FROM table_name WHERE id = ?` 形式のSQLをサポートします。
    -   B+Treeから指定されたキーのエントリを削除します。

### 2.2 発展機能 (時間があれば実装)

-   **データ検索 (全件スキャン):**
    -   `SELECT * FROM table_name` 形式のSQLをサポートします。
    -   B+Treeのリーフノードをすべて走査して全データを返します。
-   **データ検索 (範囲スキャン):**
    -   `SELECT * FROM table_name WHERE id > ? AND id < ?` (または `>=`/`<=`) 形式のSQLをサポートします。
    -   B+Treeのリーフノードを範囲指定で走査します。
-   **永続化:**
    -   B+Treeのノードデータを「ページ」としてファイルに保存・読み込みする機能を追加します。
    -   起動時にデータファイルを読み込み、`COMMIT` 時または定期的に変更をファイルに書き戻します。
-   **トランザクション管理 (基礎):**
    -   `BEGIN`, `COMMIT`, `ROLLBACK` SQLコマンドを認識します。
    -   Write-Ahead Logging (WAL) の概念に基づき、変更操作をまずログエントリとして記録する仕組みを導入します (まずはメモリ上または単純なファイル追記)。
    -   `COMMIT` 時にログに基づいて実際のB+Treeに変更を反映させます。
    -   `ROLLBACK` 時に関連するログエントリを破棄します。

### 2.3 スコープ外

-   複雑な `WHERE` 句 (複数条件のAND/OR、非主キー列でのフィルタリング)
-   `ORDER BY` (主キー以外の列でのソート)
-   `JOIN` 操作
-   セカンダリインデックス
-   高度な同時実行制御 (ロックの詳細な管理、MVCC)
-   完全なリカバリ機能
-   ネットワークインターフェース (クライアント/サーバーモデル)
-   データ型チェックの詳細 (TEXT, INTEGER以外のサポート)

## 3. 技術スタック

-   **言語:** Go
-   **SQLパーサー:** `github.com/xwb1989/sqlparser` または同等のシンプルなGoライブラリ
-   **データ構造:** 自作のB+Tree (メモリ上、発展としてファイル永続化)
    -   次数 (degree) を設定可能にする。
    -   ページ分割、削除時のマージ/再配布 (基本的なもの) を実装。
-   **データシリアライズ:** Go標準の `encoding/gob` または `encoding/json`
-   **インターフェース:** コマンドラインインターフェース (CLI)。標準入力からSQLを受け付け、結果を標準出力に表示する。インタラクティブなシェルは必須ではない。
-   **テスト:** Go標準の `testing` パッケージ

## 4. データモデル (B+Tree)

-   各テーブルに対して、独立したB+Treeインスタンスを生成します。
-   **キー:** テーブルの主キー (`id` カラムの `INTEGER` 値)。
-   **バリュー (ペイロード):** 主キー以外のカラム名と値をマップ (`map[string]interface{}`) にし、それをシリアライズしたバイト列 (`[]byte`)。
-   **ノード構造:**
    -   内部ノード: キーの配列、子ノードへのポインタ（またはページID）の配列を持つ。
    -   リーフノード: キーの配列、対応するバリュー（ペイロード）の配列、隣接リーフノードへのポインタを持つ。
    -   ノードは固定サイズの「ページ」として管理されることを意識した設計（特に永続化を考慮する場合）。

## 5. 将来的な拡張の考慮点

-   **Write-Ahead Logging (WAL):** 変更操作はまずログに記録し、`COMMIT` 時にデータページに反映する流れを基本とする。ログエントリにはトランザクションIDを含める。
-   **ページ管理:** B+TreeのノードをページIDで管理し、将来的なバッファプール導入の基礎とする。
-   **トランザクションコンテキスト:** 現在のトランザクションの状態を管理する構造を用意する。

## 6. 開発手順案

1.  **プロジェクト初期化:** `go mod init`, README作成。
2.  **B+Treeコア実装 (メモリ):** ノード構造定義、Insert, Search, Delete実装。
3.  **テーブル管理:** テーブル名とB+Treeを紐付ける `map` を用意。スキーマ情報も管理。
4.  **シリアライズ:** バリューのシリアライズ/デシリアライズ処理実装。
5.  **SQLパーサー連携:** パーサー導入、`CREATE`, `INSERT`, `SELECT`, `DELETE` をB+Tree操作に変換。
6.  **CLIインターフェース:** 標準入力からSQLを受け取り、実行して結果を表示する `main` 関数作成。
7.  **(発展) 範囲/全件スキャン実装**
8.  **(発展) 永続化実装**
9.  **(発展) トランザクション基礎実装** (ログエントリ生成、`BEGIN`/`COMMIT`/`ROLLBACK` 処理)
10. **テストとドキュメント:** 単体テスト作成、README完成、`knowledge.md` 更新。 