# Day42 OS開発手順と用語解説

## 1. はじめに

Day42では、x86-64アーキテクチャ向けのシンプルなOSカーネルを作成し、QEMUエミュレータ上で起動して画面に文字を表示することを目標としました。
このドキュメントは、その過程で行った具体的な手順と、関連する主要な技術用語について解説し、理解を深めることを目的としています。

## 2. 主要な用語解説

- **OS (Operating System / オペレーティングシステム):**
  コンピュータのハードウェア（CPU、メモリ、ディスクなど）とソフトウェアリソースを効率的に管理し、ユーザーやアプリケーションに対して統一的なインターフェースを提供する基本的なソフトウェアです。OSがなければ、アプリケーションはハードウェアを直接制御する必要があり、開発が非常に複雑になります。

- **カーネル (Kernel):**
  OSの中核部分であり、最も低いレベルでハードウェアと対話します。主な役割は以下の通りです。
    - プロセス管理: プログラムの実行を管理し、CPU時間を割り当てます。
    - メモリ管理: 各プロセスが使用するメモリ空間を割り当て、保護します。
    - デバイスドライバ: ハードウェアデバイス（キーボード、ディスク、ネットワークカードなど）を制御するためのインターフェースを提供します。
    - システムコール: アプリケーションがカーネルの機能を利用するための窓口を提供します。

- **ブートローダー (Bootloader):**
  コンピュータの電源が投入された後、OSを起動するための小さなプログラムです。通常、マザーボード上のファームウェア（BIOSやUEFI）によって最初に呼び出され、ハードディスクなどのストレージデバイスからOSのカーネルイメージをメモリに読み込み、カーネルの実行を開始させます。

- **Limine:**
  今回使用したモダンなx86およびx86-64アーキテクチャ向けのブートローダーです。シンプルな設定ファイルに基づいてカーネルをロードし、起動時にカーネルが必要とする様々な情報（メモリマップ、フレームバッファ情報、ACPIテーブルなど）を提供してくれます。

- **BIOS (Basic Input/Output System):**
  PC/AT互換機などで伝統的に使われてきたファームウェアです。マザーボード上のROMチップに格納されており、電源投入時にハードウェアの初期化（POST: Power-On Self Test）を行い、ブートデバイスからブートローダーを読み込んで実行します。

- **UEFI (Unified Extensible Firmware Interface):**
  BIOSの後継として策定された、より高機能で柔軟なファームウェアインターフェースです。セキュアブート機能、大きなディスクのサポート、グラフィカルなブートメニューなどが特徴です。LimineはBIOSとUEFIの両方に対応しています。

- **フレームバッファ (Framebuffer):**
  画面に表示される内容をピクセル単位で保持するメモリ領域のことです。このメモリ領域に直接ピクセルデータを書き込むことで、画面に画像や文字を描画できます。VGAテキストモードのようなハードウェアに依存した表示方法ではなく、より柔軟なグラフィック表示が可能です。Limineは初期化済みのフレームバッファ情報をカーネルに渡してくれます。

- **ピッチ (Pitch / Stride):**
  フレームバッファにおいて、画面の一行分のデータが占めるバイト数を指します。通常は「画面の横幅ピクセル数 × 1ピクセルあたりのバイト数」と一致しますが、メモリのアライメント（特定のアドレス境界にデータを配置すること）のために、実際の横幅よりも大きな値になることがあります。描画位置を計算する際に重要になります。

- **リンカスクリプト (Linker Script):**
  ソースコードをコンパイルして得られた複数のオブジェクトファイル（機械語コードやデータのかたまり）を、最終的な実行可能ファイル（今回の場合はカーネルイメージ `kernel.elf`）にどのように配置するかをリンカ（ldコマンドなど）に指示するための設定ファイルです。カーネルのメモリ上の開始アドレス（ベースアドレス）、各セクション（コードセクション `.text`、データセクション `.data`、BSSセクション `.bss` など）の配置順序やアライメントなどを定義します。

- **QEMU (Quick Emulator):**
  様々なCPUアーキテクチャ（x86, ARM, MIPSなど）のマシン全体をエミュレートできるオープンソースのソフトウェアです。OS開発においては、作成中のOSを実機に書き込むことなく、PC上で手軽に起動テストやデバッグを行うために広く利用されます。

- **ISOイメージ (.iso file):**
  CD-ROMやDVD-ROMなどの光学ディスクの内容を一つのファイルにまとめたアーカイブファイルフォーマットです。ブート可能なOSのイメージを配布したり、QEMUのようなエミュレータで仮想的な光学ドライブとしてマウントしたりするのによく使われます。今回は、Limineとカーネルを含んだブート可能なISOイメージを作成しました。

- **ビットマップフォント (Bitmap Font):**
  文字の形を、ピクセルの集まり（ビットマップイメージ）として定義したフォントです。各文字は固定サイズのグリッド（例: 8x8ピクセル、16x16ピクセル）で表現されます。実装が比較的単純で、OSの初期段階や組み込みシステムなどでよく利用されます。今回は8x8ピクセルのASCII文字セットを使用しました。

- **GDT (Global Descriptor Table):**
  x86アーキテクチャにおいて、プロテクトモードやロングモードでメモリセグメント（コードセグメント、データセグメントなど）の属性（ベースアドレス、リミット、アクセス権など）を定義するディスクリプタを格納するテーブルです。OSがメモリ空間を管理し保護するために不可欠です。

- **IDT (Interrupt Descriptor Table):**
  x86アーキテクチャにおいて、割り込みや例外が発生した際にCPUがどの処理ルーチン（割り込みハンドラ）を呼び出すべきかを定義するディスクリプタを格納するテーブルです。ハードウェア割り込み（キーボード入力、タイマーなど）やソフトウェア例外（ゼロ除算、ページフォルトなど）に対応するために必要です。

## 3. 実行した手順

以下に、Day42でOSカーネルを起動し、画面に文字を表示させるまでに行った主要な手順を時系列で示します。

### 3.1. プロジェクト初期設定とブートローダーの導入

1.  **作業ディレクトリと関連ファイルの準備:** OS開発のための基本的なディレクトリ構造 (`kernel/`, `image/`, `scripts/`) を作成しました。
2.  **Limineブートローダーの取得:** モダンなブートローダーであるLimineのv9.x-binaryリリースをクローンし、プロジェクト内に配置しました (`day42_original_os/limine/`)。これにより、自前で複雑なブートストラップコードを書く手間を省きます。
3.  **Limine設定ファイルの作成 (`image/limine.conf`):** Limineに対して、カーネルイメージの場所や起動時のオプションを指示する設定ファイルです。
    ```conf
    TIMEOUT=5
    DEFAULT_ENTRY=1

    :KERNEL(kernel)
    COMMENT=My Custom Kernel
    PROTOCOL=limine
    KERNEL_PATH=boot:///boot/kernel.elf
    # KERNEL_CMDLINE=Hello
    ```
    - `TIMEOUT=5`: 起動メニューの表示時間（秒）。
    - `KERNEL_PATH=boot:///boot/kernel.elf`: ISOイメージ内の `/boot/kernel.elf` をカーネルとしてロードするよう指定。
4.  **Makefileの初期作成:** カーネルのコンパイル、ISOイメージの作成、QEMUでの実行を自動化するための `Makefile` を作成しました。
    - **カーネルのコンパイル:** Cソースコード (`kernel/main.c`) を `x86_64-elf-gcc` (クロスコンパイラ) でコンパイルし、リンカスクリプト (`scripts/linker.ld`) を用いて `kernel.elf` (ELF形式の実行ファイル) を生成します。
    - **ISOイメージの作成:**
        - 必要なファイル (Limineのブートローダーファイル、設定ファイル、カーネルイメージ) を一時ディレクトリにコピー。
        - `xorriso` コマンドを使って、これらのファイルからブート可能なISOイメージ (`image/os.iso`) を生成します。El Torito規格に準拠し、BIOSブートとUEFIブートの両方に対応する設定を行いました。
        - `limine bios-install image/os.iso` コマンドを実行して、ISOイメージにBIOSブート用の情報を埋め込みます。
    - **QEMUでの実行:**
        - `make run-bios`: BIOSモードでQEMUを起動 (`-machine pc`)。
        - `make run-uefi`: UEFIモードでQEMUを起動 (`-machine q35 -bios OVMF_CODE.fd`)。

### 3.2. 最小限のカーネル作成 (エントリーポイントとフレームバッファ要求)

1.  **カーネルソースファイル (`kernel/main.c`):**
    - C言語で記述。OSの本体となるコードです。
    - Limineが提供するヘッダーファイル (`limine.h`) をインクルードします。これはLimineから情報を受け取るために必要です。
2.  **エントリーポイント (`_start`):** カーネルが最初に実行する関数です。`Makefile` 中のリンカ設定で、この `_start` シンボルをカーネルのエントリーポイントとして指定します。
3.  **フレームバッファ要求:**
    ```c
    static volatile struct limine_framebuffer_request framebuffer_request = {
        .id = LIMINE_FRAMEBUFFER_REQUEST,
        .revision = 0
    };
    ```
    - Limineに対して、「フレームバッファの情報が欲しい」と要求するための構造体です。
    - `.id = LIMINE_FRAMEBUFFER_REQUEST` で要求の種類を指定します。
    - `volatile` キーワードは、コンパイラによる最適化でこの変数が消されたり、アクセスが省略されたりするのを防ぎます。
    - `static` とすることで、この変数のスコープをファイル内に限定します。
    - この構造体を特定のセクション (`.requests`) に配置することで、Limineが起動時にこれを見つけて処理します。
4.  **リンカスクリプト (`scripts/linker.ld`):**
    ```ld
    ENTRY(_start)
    SECTIONS
    {
        . = 0xffffffff80000000;
        _kernel_start = .;

        .text : ALIGN(4K) {
            *(.text .text.*)
        }

        .requests : ALIGN(4K) {
            *(.requests)
        }
        KEEP(*(.requests))

        .rodata : ALIGN(4K) {
            *(.rodata .rodata.*)
        }

        .data : ALIGN(4K) {
            *(.data .data.*)
        }

        .bss : ALIGN(4K) {
            *(.bss .bss.*)
            *(COMMON)
        }

        _kernel_end = .;
    }
    ```
    - `ENTRY(_start)`: カーネルの実行開始点を `_start` 関数に指定。
    - `. = 0xffffffff80000000;`: カーネルがメモリ上にロードされるベースアドレス（開始番地）を指定。これはx86-64のHigher Half Kernel（カーネル空間をメモリの高位アドレスに置く設計）で一般的な値です。
    - `.requests` セクション: Limineへのリクエスト構造体を配置するための専用セクション。`KEEP(*(.requests))` で、未使用でも削除されないようにします。
    - その他、`.text` (コード)、`.rodata` (読み取り専用データ)、`.data` (初期化済みデータ)、`.bss` (未初期化データ) といった標準的なセクションを定義。

### 3.3. フレームバッファへの描画 (画面クリアと単色塗りつぶし)

1.  **フレームバッファ情報の取得:** `_start` 関数内で、Limineからのレスポンス (`framebuffer_request.response`) を確認し、利用可能なフレームバッファ (`framebuffers[0]`) の情報を取得します。
    - `address`: フレームバッファのメモリアドレス。
    - `width`: 画面の幅 (ピクセル数)。
    - `height`: 画面の高さ (ピクセル数)。
    - `pitch`: 画面の一行分のバイト数。
    - `bpp`: 1ピクセルあたりのビット数 (Bits Per Pixel)。
2.  **画面クリア処理:** 取得したフレームバッファ情報に基づき、画面全体を特定の色 (最初は青色 `0x0000FF`) で塗りつぶすループ処理を実装しました。
    ```c
    // 簡易的な画面クリア
    uint32_t *fb_ptr = (uint32_t *)framebuffer->address;
    for (uint64_t y = 0; y < framebuffer->height; y++) {
        for (uint64_t x = 0; x < framebuffer->width; x++) {
            fb_ptr[y * (framebuffer->pitch / 4) + x] = color;
        }
    }
    ```
    - `framebuffer->address` を `uint32_t` (32ビット符号なし整数) のポインタにキャストしてピクセル操作を行います (32bppを想定)。
    - `pitch` はバイト単位なので、`uint32_t` の配列としてアクセスするために4で割っています。
3.  **無限ループと`hlt`:** 画面描画後、CPUが停止しないように無限ループ (`for (;;) {}`) を配置し、その中で `asm volatile ("hlt")` を実行してCPUを低消費電力の停止状態にしました。これにより、QEMUが無駄にCPU資源を消費するのを抑えます。
4.  **QEMUでの動作確認:** `make run-bios` を実行し、QEMUの画面全体が指定した色で塗りつぶされることを確認しました。これが最初の画面出力成功です。

### 3.4. ビットマップフォントの導入と文字表示機能の実装

画面に意味のある情報を表示するため、文字描画機能を実装しました。

1.  **ビットマップフォントの用意:** シンプルな8x8ピクセルのモノクロームビットマップフォント (`font8x8_basic.h`) をWebで見つけ、プロジェクト (`kernel/font8x8_basic.h`) に追加しました。これは、ASCII文字コード0から127に対応する各文字のピクセルパターンを `uint8_t` の配列として定義したものです。
    ```c
    // font8x8_basic.h の一部 (例: 'A')
    static const uint8_t font8x8_basic[128][8] = {
        // ...
        { 0x00, 0x18, 0x24, 0x42, 0x7E, 0x42, 0x42, 0x00},   // U+0041 'A'
        // ...
    };
    ```
    各行の `uint8_t` 値が、文字の1行分の8ピクセルパターンを表します (1が前景ピクセル、0が背景ピクセル)。
2.  **`put_char` 関数の実装:** 指定された文字を、指定された座標に、指定された前景色・背景色で描画する関数です。
    - 入力: フレームバッファ情報、文字、描画開始X座標、描画開始Y座標、前景色(fg)、背景色(bg)。
    - 処理:
        - 文字コードに対応するフォントデータを `font8x8_basic` 配列から取得。
        - フォントデータの各行 (8行) についてループ。
        - 各行のビットパターン (8ビット) を1ビットずつチェック。
        - ビットが1ならフレームバッファの対応するピクセルに前景色を、0なら背景色を描画。
3.  **カーソル管理と `put_string` 関数の実装:** 画面上に連続して文字列を描画するための仕組みです。
    - グローバル変数としてカーソル位置 (`cursor_x`, `cursor_y`)、文字色 (`text_color`)、背景色 (`bg_color`) を導入。
    - `put_string` 関数:
        - 内部で `put_char` を呼び出し、一文字ずつ描画。
        - 描画後、`cursor_x` をフォント幅分進める。
        - 特殊文字の処理:
            - `\n` (改行): `cursor_x` を0に戻し、`cursor_y` をフォント高さ分進める。
            - `\r` (復帰): `cursor_x` を0に戻す。
        - 画面端での折り返し: `cursor_x` が画面幅を超えたら改行と同様の処理。
        - 画面下端でのスクロール (簡易版): `cursor_y` が画面高さを超えたら、画面全体をクリアし、カーソルを左上 (`0,0`) に戻す。
4.  **数値表示ユーティリティ (`put_hex`, `itoa_simple`):** デバッグ情報として数値（特に16進数）を表示するために、簡単な整数から文字列への変換関数と16進数表示関数を作成しました。
5.  **`_start` 関数からの呼び出し:** 画面クリア後、`put_string` や `put_hex` を使って、あいさつメッセージ、フレームバッファ情報、画面解像度などを表示するようにしました。

### 3.5. 文字サイズのスケーリング機能

8x8ピクセルのフォントは現代のディスプレイでは小さすぎるため、表示サイズを大きくする機能を実装しました。

1.  **スケーリング係数の導入:** `FONT_SCALE` というグローバル変数を導入し、文字の拡大率 (例: 2なら縦横2倍) を指定できるようにしました。
2.  **描画ロジックの変更 (`put_char`):**
    - フォントデータの1ピクセルを描画する際に、フレームバッファ上では `FONT_SCALE` x `FONT_SCALE` の矩形領域を指定色で塗りつぶすように変更しました。
    - これにより、元のフォントデータの解像度を保ちつつ、見た目のサイズを大きくできます。
3.  **実効フォントサイズの定義:** スケーリング後のフォントの幅と高さを `#define` マクロ (`EFFECTIVE_FONT_WIDTH`, `EFFECTIVE_FONT_HEIGHT`) で定義し、`put_string` でのカーソル移動や改行処理に利用するようにしました。

### 3.6. ビルドエラーとリンカエラーの修正

開発過程でいくつかのビルド関連の問題に遭遇し、修正を行いました。

1.  **`memcpy` 未定義エラー:**
    - **原因:** `-nostdlib` オプション付きでカーネルをコンパイルしているため、標準Cライブラリ関数 (`memcpy` など) がリンクされません。
    - **対策:** `kernel/main.c` 内に、自前の簡単な `memcpy` 関数を実装しました。
    ```c
    void *memcpy(void *dest, const void *src, size_t n) {
        uint8_t *pdest = (uint8_t *)dest;
        const uint8_t *psrc = (const uint8_t *)src;
        for (size_t i = 0; i < n; i++) {
            pdest[i] = psrc[i];
        }
        return dest;
    }
    ```
2.  **初期化子のコンパイル時定数エラー:**
    - **原因:** `static int EFFECTIVE_FONT_WIDTH = FONT_DATA_WIDTH * FONT_SCALE;` のようなグローバル/静的変数の初期化において、`FONT_SCALE` が実行時まで値が確定しない変数として扱われたため、「初期化子がコンパイル時定数ではない」というエラーが発生しました。
    - **対策:** `EFFECTIVE_FONT_WIDTH` と `EFFECTIVE_FONT_HEIGHT` を `static int` 変数から `#define` マクロに変更しました。マクロはプリプロセッサによって展開されるため、コンパイル時には定数値として扱われます。
    ```c
    #define EFFECTIVE_FONT_WIDTH (FONT_DATA_WIDTH * FONT_SCALE)
    #define EFFECTIVE_FONT_HEIGHT (FONT_DATA_HEIGHT * FONT_SCALE)
    ```

### 3.7. Gitへのコミット

ここまでの変更をGitリポジトリにコミットしました。主なコミット対象ファイルは以下の通りです。

- `kernel/main.c` (カーネル本体)
- `kernel/font8x8_basic.h` (ビットマップフォント)
- `kernel/limine.h` (Limineヘッダー)
- `Makefile` (ビルドスクリプト)
- `image/limine.conf` (Limine設定ファイル)
- `limine/` (Limineブートローダーファイル群)
- `scripts/linker.ld` (リンカスクリプト)
- `PROGRESS.md` (進捗管理ファイル)
- `README.md` (プロジェクト説明ファイル)

コミットメッセージ: `day42: feat: Implement basic console output with scalable 8x8 font`

## 4. 現状と次のステップ

- **現状:** Limineブートローダーを経由して自作カーネルが起動し、フレームバッファを利用して画面上にスケーリング可能な文字を表示できる状態になりました。
- **次のステップの案:**
    - **GDT (Global Descriptor Table) のセットアップ:** プロテクトモード/ロングモードで必須のセグメントディスクリプタを設定します。
    - **IDT (Interrupt Descriptor Table) のセットアップ:** 割り込みハンドリングの基礎を築きます。まずは例外（例: Division by Zero）のハンドリングから始めることが多いです。
    - **シリアルポート出力:** QEMUのシリアルポート経由でデバッグメッセージを出力できるようにすると、画面表示よりも手軽にログを確認できます。
    - **物理メモリ管理 (Physical Memory Manager / PMM):** Limineから受け取ったメモリマップ情報を基に、利用可能な物理メモリ領域を管理する機構を実装します。
    - **ページング (Paging / 仮想メモリ管理):** 物理メモリをページ単位で管理し、仮想アドレス空間を物理アドレス空間にマッピングする仕組みを有効にします。これによりメモリ保護や効率的なメモリ利用が可能になります。

以上がDay42の作業内容と関連技術の概要です。
