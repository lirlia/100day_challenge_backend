package router

import (
	"bytes"
	"container/heap"
	"context"
	"encoding/binary"
	"encoding/gob"
	"fmt"
	"log"
	"net"
	"sync"
	"time"
)

const (
	ospfHelloInterval     = 10 * time.Second
	ospfLSAUpdateInterval = 30 * time.Second
	lsaMaxAge             = 1 * time.Hour // LSAの最大有効期間 (例)
	defaultLSAMetric      = 10
)

// OSPFLinkState represents a link to a neighbor router or a stub network.
// This is part of an LSA.
type OSPFLinkState struct {
	LinkType          string    // "router" or "network"
	NeighborRouterID  string    // If LinkType is "router", the ID of the neighbor router.
	Network           net.IPNet // If LinkType is "network", the network address (e.g., router's TUN net).
	Metric            int       // Cost to this link.
	LocalInterfaceIP  net.IP    // IP of this router on the link (for router links)
	RemoteInterfaceIP net.IP    // IP of the neighbor router on the link (for router links)
}

// LSA (Link State Advertisement) represents the state of a router's links.
// This is a simplified LSA.
type LSA struct {
	AdvertisingRouterID string          // Router ID of the LSA originator.
	SequenceNumber      int64           // Incremented for each new LSA from the same router.
	Timestamp           time.Time       // Time of LSA generation.
	Links               []OSPFLinkState // List of links and their states.
	TTL                 int             // Time To Live for LSA (not standard OSPF, but for simplicity)
}

// LSDBEntry wraps an LSA with metadata for storage in the Link State Database.
type LSDBEntry struct {
	Lsa             *LSA
	ReceivedAt      time.Time
	IsSelfGenerated bool // True if this LSA was generated by the local router.
}

// OSPFNeighborData holds information about an OSPF neighbor.
type OSPFNeighborData struct {
	RouterID string
	// lastHelloReceived time.Time
	// state (e.g. Down, Init, TwoWay, Full)
}

// OSPFInstance manages the OSPF protocol logic for a single router.
type OSPFInstance struct {
	router             *Router               // Parent router
	lsdb               map[string]*LSDBEntry // Link State Database: key is AdvertisingRouterID
	lsdbMutex          sync.RWMutex
	sequenceNumber     int64 // Local LSA sequence number
	sequenceNumberLock sync.Mutex
	neighbors          map[string]*OSPFNeighborData // key is NeighborRouterID (from Router.NeighborLinks)
	neighborMutex      sync.RWMutex
	helloTicker        *time.Ticker
	lsaUpdateTicker    *time.Ticker
	ctx                context.Context
	cancelFunc         context.CancelFunc
	wg                 sync.WaitGroup
}

// NewOSPFInstance creates and initializes a new OSPFInstance.
func NewOSPFInstance(r *Router) *OSPFInstance {
	ctx, cancel := context.WithCancel(r.ctx) // Inherit parent router's context
	oi := &OSPFInstance{
		router:          r,
		lsdb:            make(map[string]*LSDBEntry),
		sequenceNumber:  time.Now().UnixNano(), // Initial sequence number
		neighbors:       make(map[string]*OSPFNeighborData),
		helloTicker:     time.NewTicker(ospfHelloInterval),
		lsaUpdateTicker: time.NewTicker(ospfLSAUpdateInterval),
		ctx:             ctx,
		cancelFunc:      cancel,
	}
	r.SetOSPFInstance(oi) // Register with the router
	return oi
}

// Start begins the OSPF process for this router instance.
func (oi *OSPFInstance) Start() {
	log.Printf("Router %s: OSPF instance starting...", oi.router.ID)
	oi.wg.Add(1)
	go oi.run()

	// Initialize neighbors from existing router links
	oi.router.neighborLinksMutex.RLock()
	for neighborID := range oi.router.NeighborLinks {
		oi.AddNeighbor(neighborID)
	}
	oi.router.neighborLinksMutex.RUnlock()

	// Generate and flood initial LSA
	oi.generateAndFloodLSA()
	log.Printf("Router %s: OSPF instance started.", oi.router.ID)
}

// Stop terminates the OSPF process.
func (oi *OSPFInstance) Stop() {
	log.Printf("Router %s: OSPF instance stopping...", oi.router.ID)
	oi.cancelFunc()
	oi.helloTicker.Stop()
	oi.lsaUpdateTicker.Stop()
	oi.wg.Wait()
	log.Printf("Router %s: OSPF instance stopped.", oi.router.ID)
}

func (oi *OSPFInstance) getNextSequenceNumber() int64 {
	oi.sequenceNumberLock.Lock()
	defer oi.sequenceNumberLock.Unlock()
	oi.sequenceNumber++
	return oi.sequenceNumber
}

// generateLSA creates a new LSA for the current state of the router.
func (oi *OSPFInstance) generateLSA() *LSA {
	lsa := &LSA{
		AdvertisingRouterID: oi.router.ID,
		SequenceNumber:      oi.getNextSequenceNumber(),
		Timestamp:           time.Now(),
		Links:               make([]OSPFLinkState, 0),
		TTL:                 int(lsaMaxAge.Seconds()),
	}

	// Add link for the router's own TUN network (stub network)
	lsa.Links = append(lsa.Links, OSPFLinkState{
		LinkType: "network",
		Network:  oi.router.IPAddress, // The router's own IP network
		Metric:   1,                   // Metric to own network is typically low
	})

	// Add links for each active neighbor
	oi.router.neighborLinksMutex.RLock()
	for neighborID, link := range oi.router.NeighborLinks {
		lsa.Links = append(lsa.Links, OSPFLinkState{
			LinkType:          "router",
			NeighborRouterID:  neighborID,
			Metric:            link.Cost,
			LocalInterfaceIP:  link.LocalInterfaceIP,
			RemoteInterfaceIP: link.RemoteInterfaceIP,
		})
	}
	oi.router.neighborLinksMutex.RUnlock()

	log.Printf("Router %s: Generated LSA (Seq: %d, Links: %d)", oi.router.ID, lsa.SequenceNumber, len(lsa.Links))
	return lsa
}

// floodLSA sends the LSA to all OSPF neighbors.
func (oi *OSPFInstance) floodLSA(lsa *LSA) {
	log.Printf("Router %s: Flooding LSA (AdvRtr: %s, Seq: %d) to neighbors.", oi.router.ID, lsa.AdvertisingRouterID, lsa.SequenceNumber)

	// Serialize LSA for sending via channels
	var lsaBuffer bytes.Buffer
	encoder := gob.NewEncoder(&lsaBuffer)
	if err := encoder.Encode(lsa); err != nil {
		log.Printf("Router %s: Error encoding LSA for flooding: %v", oi.router.ID, err)
		return
	}
	lsaBytes := lsaBuffer.Bytes()

	oi.router.neighborLinksMutex.RLock()
	for neighborID, link := range oi.router.NeighborLinks {
		// Don't send LSA back to the neighbor it was received from if this were a more complex flooding mechanism.
		// For now, always send to all neighbors (except if it's the originator).
		if lsa.AdvertisingRouterID == neighborID && !oi.isSelfLSA(lsa) { // Basic loop prevention
			// log.Printf("Router %s: Not flooding LSA from %s back to itself.", oi.router.ID, neighborID)
			continue
		}

		log.Printf("Router %s: Sending LSA (AdvRtr: %s, Seq: %d) to neighbor %s via channel", oi.router.ID, lsa.AdvertisingRouterID, lsa.SequenceNumber, neighborID)
		// Need a way to distinguish OSPF control packets from data packets on the neighbor link channels.
		// For simplicity, we might reuse the existing data channel and rely on packet type inspection (e.g. IP protocol for OSPF)
		// Or, add a dedicated control channel to NeighborLink.
		// For now, we assume the channel can carry these types or we need a wrapper.
		// This is a placeholder. Actual OSPF packets are not raw LSA structs over a Go channel.
		// OSPF runs over IP (protocol 89). We'd encapsulate LSA updates in OSPF packets.
		// For this simulation, we send the gob-encoded LSA directly.

		// Create a pseudo OSPF packet (using a specific IP protocol number for OSPF, e.g. 89)
		// This packet will wrap the LSA data.
		ospfPacket, err := oi.createOSPFPacket(lsaBytes, link.LocalInterfaceIP, link.RemoteInterfaceIP) // Destination is neighbor's link IP
		if err != nil {
			log.Printf("Router %s: Failed to create OSPF packet for neighbor %s: %v", oi.router.ID, neighborID, err)
			continue
		}

		select {
		case link.ToNeighborChan <- ospfPacket:
			// log.Printf("Router %s: Successfully sent LSA to neighbor %s", oi.router.ID, neighborID)
		case <-time.After(2 * time.Second):
			log.Printf("Router %s: Timeout sending LSA to neighbor %s", oi.router.ID, neighborID)
		case <-oi.ctx.Done():
			log.Printf("Router %s: OSPF context done, not sending LSA to %s", oi.router.ID, neighborID)
			return // Exit if context is cancelled
		}
	}
	oi.router.neighborLinksMutex.RUnlock()
}

// createOSPFPacket encapsulates OSPF data (like an LSA) into an IP packet.
// For simulation purposes, we use protocol 89 (OSPF).
func (oi *OSPFInstance) createOSPFPacket(ospfPayload []byte, srcIP, destIP net.IP) ([]byte, error) {
	ipHdr := IPv4Header{
		VersionIHL:     (4 << 4) | 5, // IPv4, IHL 5 (20 bytes)
		DSCPECN:        0,
		TotalLength:    uint16(20 + len(ospfPayload)),
		Identification: 0, // OSPF packets might not need specific ID for this simulation
		FlagsFragment:  0,
		TTL:            1,  // OSPF packets are typically link-local or not forwarded far by default
		Protocol:       89, // OSPF Protocol Number
		SourceAddress:  srcIP,
		DestAddress:    destIP,
	}
	ipHdrBytes, err := ipHdr.Marshal()
	if err != nil {
		return nil, fmt.Errorf("failed to marshal OSPF IP header: %w", err)
	}
	ipHdr.HeaderChecksum = CalculateChecksum(ipHdrBytes)
	binary.BigEndian.PutUint16(ipHdrBytes[10:12], ipHdr.HeaderChecksum)

	return append(ipHdrBytes, ospfPayload...), nil
}

// HandleReceivedOSPFPacket processes an incoming IP packet that is identified as OSPF.
func (oi *OSPFInstance) HandleReceivedOSPFPacket(packet []byte, sourceIP net.IP, sourceNeighborID string) {
	ipv4Hdr, err := ParseIPv4Header(packet)
	if err != nil {
		log.Printf("Router %s: OSPF: Error parsing IPv4 header from supposedly OSPF packet from %s: %v", oi.router.ID, sourceNeighborID, err)
		return
	}
	if ipv4Hdr.Protocol != 89 { // Not OSPF
		log.Printf("Router %s: OSPF: Received packet with non-OSPF protocol %d from %s. Ignoring.", oi.router.ID, ipv4Hdr.Protocol, sourceNeighborID)
		return
	}

	headerLen := int(ipv4Hdr.VersionIHL&0x0F) * 4
	if len(packet) <= headerLen {
		log.Printf("Router %s: OSPF: Received packet too short for OSPF payload from %s.", oi.router.ID, sourceNeighborID)
		return
	}
	lsaBytes := packet[headerLen:]

	var receivedLSA LSA
	decoder := gob.NewDecoder(bytes.NewReader(lsaBytes))
	if err := decoder.Decode(&receivedLSA); err != nil {
		log.Printf("Router %s: OSPF: Error decoding LSA from neighbor %s: %v", oi.router.ID, sourceNeighborID, err)
		return
	}

	log.Printf("Router %s: OSPF: Received LSA from %s (AdvRtr: %s, Seq: %d). Processing...", oi.router.ID, sourceNeighborID, receivedLSA.AdvertisingRouterID, receivedLSA.SequenceNumber)
	oi.processReceivedLSA(&receivedLSA, sourceNeighborID)
}

func (oi *OSPFInstance) isSelfLSA(lsa *LSA) bool {
	return lsa.AdvertisingRouterID == oi.router.ID
}

// processReceivedLSA updates the LSDB and refloods if necessary.
func (oi *OSPFInstance) processReceivedLSA(lsa *LSA, fromNeighborID string) {
	if oi.isSelfLSA(lsa) {
		// log.Printf("Router %s: OSPF: Received self-originated LSA (Seq: %d). Ignoring.", oi.router.ID, lsa.SequenceNumber)
		return // Ignore self-originated LSAs received back unless specific handling is needed.
	}

	oi.lsdbMutex.Lock()
	defer oi.lsdbMutex.Unlock()

	existingEntry, exists := oi.lsdb[lsa.AdvertisingRouterID]
	if exists {
		if lsa.SequenceNumber <= existingEntry.Lsa.SequenceNumber && lsa.Timestamp.Before(existingEntry.Lsa.Timestamp) {
			// log.Printf("Router %s: OSPF: Received older or same LSA for %s (Seq %d <= %d). Ignoring.", oi.router.ID, lsa.AdvertisingRouterID, lsa.SequenceNumber, existingEntry.Lsa.SequenceNumber)
			return
		}
		// More recent LSA or same sequence with newer timestamp
		log.Printf("Router %s: OSPF: Updating LSA for %s (New Seq: %d, Old Seq: %d)", oi.router.ID, lsa.AdvertisingRouterID, lsa.SequenceNumber, existingEntry.Lsa.SequenceNumber)
	} else {
		log.Printf("Router %s: OSPF: New LSA received for %s (Seq: %d). Adding to LSDB.", oi.router.ID, lsa.AdvertisingRouterID, lsa.SequenceNumber)
	}

	oi.lsdb[lsa.AdvertisingRouterID] = &LSDBEntry{
		Lsa:             lsa,
		ReceivedAt:      time.Now(),
		IsSelfGenerated: false, // This is a received LSA
	}

	// LSDB changed, trigger SPF calculation
	oi.triggerSPFCalculation()

	// Reflood LSA to other neighbors (except the one it came from and not back to originator if from non-originator)
	// Simple flooding: flood to all *other* neighbors.
	// A more robust flooding would avoid sending it back to `fromNeighborID`.
	go oi.floodLSA(lsa) // Flood in a new goroutine to avoid blocking
}

func (oi *OSPFInstance) run() {
	defer oi.wg.Done()
	log.Printf("Router %s: OSPF run loop started.", oi.router.ID)
	for {
		select {
		case <-oi.ctx.Done():
			log.Printf("Router %s: OSPF run loop stopping due to context cancellation.", oi.router.ID)
			return
		// case <-oi.helloTicker.C:
		// 	// log.Printf("Router %s: OSPF Hello Timer tick. Sending Hellos...", oi.router.ID)
		// 	// oi.sendHellos()
		case <-oi.lsaUpdateTicker.C:
			log.Printf("Router %s: OSPF LSA Update Timer tick. Regenerating and flooding LSA.", oi.router.ID)
			oi.generateAndFloodLSA()
			// TODO: LSDB aging and cleanup
		}
	}
}

func (oi *OSPFInstance) generateAndFloodLSA() {
	lsa := oi.generateLSA()
	// Add self-generated LSA to own LSDB
	oi.lsdbMutex.Lock()
	oi.lsdb[oi.router.ID] = &LSDBEntry{
		Lsa:             lsa,
		ReceivedAt:      time.Now(),
		IsSelfGenerated: true,
	}
	oi.lsdbMutex.Unlock()

	oi.triggerSPFCalculation() // Calculate SPF with new self LSA
	oi.floodLSA(lsa)
}

// triggerSPFCalculation starts the SPF calculation process.
func (oi *OSPFInstance) triggerSPFCalculation() {
	log.Printf("Router %s: OSPF: Triggering SPF calculation.", oi.router.ID)
	// Run SPF in a goroutine to avoid blocking the caller (e.g., LSA processing)
	go func() {
		newRoutes := oi.calculateSPF()
		if newRoutes == nil {
			// log.Printf("Router %s: OSPF: SPF calculation resulted in no new routes or no change.", oi.router.ID)
			return
		}
		log.Printf("Router %s: OSPF: SPF calculation complete. Found %d routes. Updating routing table.", oi.router.ID, len(newRoutes))
		oi.updateRoutingTable(newRoutes)
	}()
}

// SPF calculation (Dijkstra's algorithm)
// Represents a node in the Dijkstra graph
type spfNode struct {
	routerID string
	distance int
	prevHop  string // Previous router ID in the shortest path
	index    int    // Index in the priority queue
}

// Priority queue for Dijkstra
type spfPriorityQueue []*spfNode

func (pq spfPriorityQueue) Len() int { return len(pq) }
func (pq spfPriorityQueue) Less(i, j int) bool {
	return pq[i].distance < pq[j].distance
}
func (pq spfPriorityQueue) Swap(i, j int) {
	pq[i], pq[j] = pq[j], pq[i]
	pq[i].index = i
	pq[j].index = j
}
func (pq *spfPriorityQueue) Push(x interface{}) {
	n := len(*pq)
	node := x.(*spfNode)
	node.index = n
	*pq = append(*pq, node)
}
func (pq *spfPriorityQueue) Pop() interface{} {
	old := *pq
	n := len(old)
	node := old[n-1]
	old[n-1] = nil  // avoid memory leak
	node.index = -1 // for safety
	*pq = old[0 : n-1]
	return node
}

// update modifies the priority and value of an Item in the queue.
func (pq *spfPriorityQueue) update(node *spfNode, distance int, prevHop string) {
	node.distance = distance
	node.prevHop = prevHop
	heap.Fix(pq, node.index)
}

func (oi *OSPFInstance) calculateSPF() map[string]*RoutingEntry {
	oi.lsdbMutex.RLock()
	defer oi.lsdbMutex.RUnlock()

	if len(oi.lsdb) == 0 {
		log.Printf("Router %s: OSPF: LSDB is empty, cannot calculate SPF.", oi.router.ID)
		return nil
	}

	distances := make(map[string]int)    // routerID -> shortest distance from self
	prevHops := make(map[string]string)  // routerID -> previous hop routerID in shortest path
	finalized := make(map[string]bool)   // routerID -> true if shortest path is finalized
	pqNodes := make(map[string]*spfNode) // routerID -> spfNode for priority queue management

	pq := make(spfPriorityQueue, 0, len(oi.lsdb))
	heap.Init(&pq)

	// Initialize distances: self is 0, others are infinity
	for advRouterID := range oi.lsdb {
		distances[advRouterID] = 1 << 30 // Effectively infinity
		if advRouterID == oi.router.ID {
			distances[advRouterID] = 0
		}
		node := &spfNode{routerID: advRouterID, distance: distances[advRouterID]}
		pqNodes[advRouterID] = node
		heap.Push(&pq, node)
	}

	for pq.Len() > 0 {
		uNode := heap.Pop(&pq).(*spfNode)
		uID := uNode.routerID

		if finalized[uID] {
			continue
		}
		finalized[uID] = true

		// Get LSA for uID
		uLSAEntry, ok := oi.lsdb[uID]
		if !ok || uLSAEntry.Lsa == nil {
			continue // Should not happen if LSDB is consistent
		}

		for _, link := range uLSAEntry.Lsa.Links {
			if link.LinkType == "router" {
				vID := link.NeighborRouterID
				if !finalized[vID] {
					altDistance := distances[uID] + link.Metric
					if altDistance < distances[vID] {
						distances[vID] = altDistance
						prevHops[vID] = uID
						if pqNode, exists := pqNodes[vID]; exists && pqNode.index != -1 { // Check if in PQ
							pq.update(pqNode, altDistance, uID)
						} else if !exists || pqNode.index == -1 { // Not in PQ or already popped
							// This case can happen if a node was popped and needs re-evaluation due to a shorter path found later
							// or if the graph isn't fully connected from the start node initially in pqNodes
							// For robust Dijkstra, if a node is not in pqNodes or its index is -1 (popped), it means
							// it was either never added (error in init) or its shortest path was thought to be found.
							// If we find a shorter path to an already finalized node, standard Dijkstra doesn't re-add.
							// However, our `finalized` map handles this. If it needs re-adding to PQ:
							// updatedNode := &spfNode{routerID: vID, distance: altDistance, prevHop: uID}
							// pqNodes[vID] = updatedNode // update our map
							// heap.Push(&pq, updatedNode)
							// For typical Dijkstra with heap.Fix, this else branch might indicate a node not yet processed or graph structure issue.
						}
					}
				}
			}
		}
	}

	// Construct routing table entries
	newRoutes := make(map[string]*RoutingEntry)
	for destRouterID, dist := range distances {
		if destRouterID == oi.router.ID || dist >= (1<<30) { // Skip self or unreachable
			continue
		}

		// Find the LSA for the destination router to get its advertised networks
		destLSAEntry, ok := oi.lsdb[destRouterID]
		if !ok || destLSAEntry.Lsa == nil {
			continue
		}

		// Determine the next hop router on the path from self to destRouterID
		nextHopRouterID := destRouterID
		pathHop := destRouterID
		for prevHops[pathHop] != "" && prevHops[pathHop] != oi.router.ID {
			nextHopRouterID = prevHops[pathHop]
			pathHop = prevHops[pathHop]
		}
		if prevHops[pathHop] == oi.router.ID {
			nextHopRouterID = pathHop
		}

		// Find the link from self to this nextHopRouterID to get the interface IP
		var nextHopIPOnLink net.IP
		var outgoingInterfaceID string // This will be the neighbor ID (link ID)

		oi.router.neighborLinksMutex.RLock()
		linkToNextHop, linkExists := oi.router.NeighborLinks[nextHopRouterID]
		if linkExists {
			nextHopIPOnLink = linkToNextHop.RemoteInterfaceIP
			outgoingInterfaceID = nextHopRouterID // Interface is identified by neighbor router ID
		} else if nextHopRouterID == oi.router.ID {
			// This case implies destRouterID is directly connected to self.
			// But the main loop for destRouterID skips self. So this branch might not be hit for nextHop determination.
			// If destRouterID is a direct neighbor, nextHopRouterID would be destRouterID.
			// And linkToNextHop should exist.
			log.Printf("Router %s: OSPF: SPF: dest %s seems to be self for nexthop calculation. Should be handled earlier.", oi.router.ID, destRouterID)
		} else {
			log.Printf("Router %s: OSPF: SPF: Could not find link to next hop router %s for destination %s. Skipping route.", oi.router.ID, nextHopRouterID, destRouterID)
			oi.router.neighborLinksMutex.RUnlock()
			continue
		}
		oi.router.neighborLinksMutex.RUnlock()

		for _, link := range destLSAEntry.Lsa.Links {
			if link.LinkType == "network" { // Create routes for networks advertised by destRouterID
				routeKey := link.Network.String()
				newRoutes[routeKey] = &RoutingEntry{
					Destination: link.Network,
					NextHop:     nextHopIPOnLink,     // The IP address of the next hop router on the link
					Interface:   outgoingInterfaceID, // The ID of the neighbor link
					Metric:      dist + link.Metric,  // Total metric to the network
					Type:        OSPFRoute,
				}
			}
		}
	}
	return newRoutes
}

// updateRoutingTable updates the main routing table based on SPF calculation results.
func (oi *OSPFInstance) updateRoutingTable(newOspfRoutes map[string]*RoutingEntry) {
	log.Printf("Router %s: OSPF: Updating routing table with %d OSPF routes...", oi.router.ID, len(newOspfRoutes))

	// 1. Remove all existing OSPF routes from the router's table
	oi.router.routingTableMutex.Lock()
	currentTable := oi.router.RoutingTable
	updatedTable := make([]*RoutingEntry, 0, len(currentTable))
	removedCount := 0
	for _, entry := range currentTable {
		if entry.Type != OSPFRoute {
			updatedTable = append(updatedTable, entry)
		} else {
			removedCount++
		}
	}
	oi.router.RoutingTable = updatedTable
	oi.router.routingTableMutex.Unlock()
	if removedCount > 0 {
		log.Printf("Router %s: OSPF: Removed %d old OSPF routes.", oi.router.ID, removedCount)
	}

	// 2. Add new OSPF routes
	addedCount := 0
	for _, newRoute := range newOspfRoutes {
		oi.router.AddRoute(newRoute) // AddRoute is thread-safe
		addedCount++
	}
	if addedCount > 0 {
		log.Printf("Router %s: OSPF: Added %d new OSPF routes.", oi.router.ID, addedCount)
	}
	// For debugging, print the new table
	// oi.router.PrintRoutingTable()
}

// HandleLinkUp is called when a neighbor link comes up.
func (oi *OSPFInstance) HandleLinkUp(neighborID string, cost int, localIP, remoteIP net.IP) {
	log.Printf("Router %s: OSPF: Link to neighbor %s came up (Cost: %d).", oi.router.ID, neighborID, cost)
	oi.AddNeighbor(neighborID)
	// Regenerate and flood LSA because router's own link state changed.
	oi.generateAndFloodLSA()
}

// HandleLinkDown is called when a neighbor link goes down.
func (oi *OSPFInstance) HandleLinkDown(neighborID string, remoteIP net.IP) {
	log.Printf("Router %s: OSPF: Link to neighbor %s (IP: %s) went down.", oi.router.ID, neighborID, remoteIP)
	oi.RemoveNeighbor(neighborID)
	// Regenerate and flood LSA because router's own link state changed.
	oi.generateAndFloodLSA()

	// Optional: Also remove LSAs originated by the downed neighbor if they are now considered stale
	// This would require more complex aging and flushing logic for LSDB entries.
}

// AddNeighbor adds an OSPF neighbor.
func (oi *OSPFInstance) AddNeighbor(neighborID string) {
	oi.neighborMutex.Lock()
	defer oi.neighborMutex.Unlock()
	if _, exists := oi.neighbors[neighborID]; !exists {
		oi.neighbors[neighborID] = &OSPFNeighborData{RouterID: neighborID}
		log.Printf("Router %s: OSPF: Added neighbor %s.", oi.router.ID, neighborID)
	} else {
		// log.Printf("Router %s: OSPF: Neighbor %s already exists.", oi.router.ID, neighborID)
	}
}

// RemoveNeighbor removes an OSPF neighbor.
func (oi *OSPFInstance) RemoveNeighbor(neighborID string) {
	oi.neighborMutex.Lock()
	defer oi.neighborMutex.Unlock()
	if _, exists := oi.neighbors[neighborID]; exists {
		delete(oi.neighbors, neighborID)
		log.Printf("Router %s: OSPF: Removed neighbor %s.", oi.router.ID, neighborID)
	} else {
		// log.Printf("Router %s: OSPF: Neighbor %s not found for removal.", oi.router.ID, neighborID)
	}
}

// This function needs to be called from router.go when an OSPF packet is identified
// The router.go handlePacket needs to check IP protocol for 89, then pass to this instance.
// func (r *Router) handleOSPFFromNeighbor(packetData []byte, fromNeighborID string, fromNeighborIP net.IP) {
// 	if r.ospfInstance != nil {
// 		r.ospfInstance.handleReceivedOSPFPacket(packetData, fromNeighborIP, fromNeighborID)
// 	}
// }
