# Day 27: HTTP プロトコル挙動シミュレーター

HTTP/1.1, HTTP/2, HTTP/3 (コンセプト) の挙動の違いを視覚的にシミュレートするアプリケーションです。
バックエンドはリソースを返すシンプルな API を持ち、フロントエンドで各プロトコルの特性（主に HOL ブロッキングと多重化）を模倣してリソース取得をシミュレートします。

https://github.com/user-attachments/assets/66bab0d0-d6ae-4a90-bffe-b6d53fbd6183

[100日チャレンジ day27 (HTTP プロトコル挙動シミュレーター)](https://zenn.dev/gin_nazo/scraps/a2ad37de80c6c5)

## デザインコンセプト

今回は **ブルータリズム** を採用し、生の HTML 要素のような見た目と、はっきりとした罫線や色使いを特徴とします。

## 主な機能

-   HTTP/1.1, HTTP/2, HTTP/3 (コンセプト) のいずれかのプロトコルを選択できます。
-   シミュレーションを開始すると、複数のリソースをバックエンド API から取得します。
-   各プロトコルの特性に基づいて、リソース取得の過程を視覚的に表示します。
    -   **HTTP/1.1**: 1つの TCP コネクション上でリクエストを順番に送り、レスポンスを待つため、Head-of-Line (HOL) ブロッキングが発生する様子をシミュレートします。リソースは直列的に取得されます。
    -   **HTTP/2**: 1つの TCP コネクション上で複数のリクエスト/レスポンスを並行して多重化できるため、HOL ブロッキングが解消される様子をシミュレートします。リソースは並行して取得されます。
    -   **HTTP/3 (コンセプト)**: QUIC プロトコルに基づき、TCP の HOL ブロッキングだけでなく、パケットロス時の HOL ブロッキングも改善されますが、このシミュレーションでは**コンセプトとして HTTP/2 と同様の多重化**の側面を視覚化することに留めます。実際の QUIC の実装はブラウザ/サーバーレベルであり、JavaScript で完全に再現することは困難なためです。
-   各リソースの取得状況（待機中、取得中、完了、失敗）を表示します。

## API 仕様

### `GET /api/resource/{id}`

指定された ID のダミーリソースを返します。意図的にランダムな遅延 (50ms〜200ms) を発生させ、ネットワークの揺らぎを模倣します。

-   **パスパラメータ:**
    -   `id`: 取得するリソースの ID (整数)
-   **レスポンス (成功時):** `200 OK`
    ```json
    {
      "id": 1,
      "data": "Resource data for ID 1"
    }
    ```
-   **レスポンス (失敗時):** `500 Internal Server Error` など

## 使い方

1.  アプリケーションを開きます (`http://localhost:3001`)。
2.  シミュレートしたい HTTP プロトコル (HTTP/1.1, HTTP/2, HTTP/3) を選択します。
3.  「Start Simulation」ボタンをクリックします。
4.  選択したプロトコルの挙動に基づいて、リソース取得の様子がリアルタイムで表示されます。
5.  各プロトコルの説明を読んで、視覚化された挙動との対応を確認します。

## 技術スタック

-   Next.js (App Router)
-   TypeScript
-   Tailwind CSS
-   React (useState, useReducer)

## 学んだこと・ポイント

-   HTTP/1.1, HTTP/2, HTTP/3 の主要な違い（HOL ブロッキング、多重化）を視覚的に理解する。
-   `Promise.all` や `async/await` を用いた非同期処理の制御。
-   `setTimeout` を用いた意図的な遅延の導入。
-   `useReducer` を用いた状態管理による、シミュレーション状態の更新。
-   フロントエンドのみでバックエンドの挙動をシミュレートする際の限界と、コンセプトの伝え方。HTTP/3 のような低レイヤープロトコルの挙動を完全に模倣することの難しさ。
-   ブルータリズムデザインの適用。
