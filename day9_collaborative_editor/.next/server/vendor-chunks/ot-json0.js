/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ot-json0";
exports.ids = ["vendor-chunks/ot-json0"];
exports.modules = {

/***/ "(ssr)/./node_modules/ot-json0/lib/bootstrapTransform.js":
/*!*********************************************************!*\
  !*** ./node_modules/ot-json0/lib/bootstrapTransform.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("// These methods let you build a transform function from a transformComponent\n// function for OT types like JSON0 in which operations are lists of components\n// and transforming them requires N^2 work. I find it kind of nasty that I need\n// this, but I'm not really sure what a better solution is. Maybe I should do\n// this automatically to types that don't have a compose function defined.\n\n// Add transform and transformX functions for an OT type which has\n// transformComponent defined.  transformComponent(destination array,\n// component, other component, side)\nmodule.exports = bootstrapTransform\nfunction bootstrapTransform(type, transformComponent, checkValidOp, append) {\n  var transformComponentX = function(left, right, destLeft, destRight) {\n    transformComponent(destLeft, left, right, 'left');\n    transformComponent(destRight, right, left, 'right');\n  };\n\n  var transformX = type.transformX = function(leftOp, rightOp) {\n    checkValidOp(leftOp);\n    checkValidOp(rightOp);\n    var newRightOp = [];\n\n    for (var i = 0; i < rightOp.length; i++) {\n      var rightComponent = rightOp[i];\n\n      // Generate newLeftOp by composing leftOp by rightComponent\n      var newLeftOp = [];\n      var k = 0;\n      while (k < leftOp.length) {\n        var nextC = [];\n        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);\n        k++;\n\n        if (nextC.length === 1) {\n          rightComponent = nextC[0];\n        } else if (nextC.length === 0) {\n          for (var j = k; j < leftOp.length; j++) {\n            append(newLeftOp, leftOp[j]);\n          }\n          rightComponent = null;\n          break;\n        } else {\n          // Recurse.\n          var pair = transformX(leftOp.slice(k), nextC);\n          for (var l = 0; l < pair[0].length; l++) {\n            append(newLeftOp, pair[0][l]);\n          }\n          for (var r = 0; r < pair[1].length; r++) {\n            append(newRightOp, pair[1][r]);\n          }\n          rightComponent = null;\n          break;\n        }\n      }\n\n      if (rightComponent != null) {\n        append(newRightOp, rightComponent);\n      }\n      leftOp = newLeftOp;\n    }\n    return [leftOp, newRightOp];\n  };\n\n  // Transforms op with specified type ('left' or 'right') by otherOp.\n  type.transform = function(op, otherOp, type) {\n    if (!(type === 'left' || type === 'right'))\n      throw new Error(\"type must be 'left' or 'right'\");\n\n    if (otherOp.length === 0) return op;\n\n    if (op.length === 1 && otherOp.length === 1)\n      return transformComponent([], op[0], otherOp[0], type);\n\n    if (type === 'left')\n      return transformX(op, otherOp)[0];\n    else\n      return transformX(otherOp, op)[1];\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3QtanNvbjAvbGliL2Jvb3RzdHJhcFRyYW5zZm9ybS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXk5X2NvbGxhYm9yYXRpdmVfZWRpdG9yLy4vbm9kZV9tb2R1bGVzL290LWpzb24wL2xpYi9ib290c3RyYXBUcmFuc2Zvcm0uanM/ODRhZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGVzZSBtZXRob2RzIGxldCB5b3UgYnVpbGQgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gZnJvbSBhIHRyYW5zZm9ybUNvbXBvbmVudFxuLy8gZnVuY3Rpb24gZm9yIE9UIHR5cGVzIGxpa2UgSlNPTjAgaW4gd2hpY2ggb3BlcmF0aW9ucyBhcmUgbGlzdHMgb2YgY29tcG9uZW50c1xuLy8gYW5kIHRyYW5zZm9ybWluZyB0aGVtIHJlcXVpcmVzIE5eMiB3b3JrLiBJIGZpbmQgaXQga2luZCBvZiBuYXN0eSB0aGF0IEkgbmVlZFxuLy8gdGhpcywgYnV0IEknbSBub3QgcmVhbGx5IHN1cmUgd2hhdCBhIGJldHRlciBzb2x1dGlvbiBpcy4gTWF5YmUgSSBzaG91bGQgZG9cbi8vIHRoaXMgYXV0b21hdGljYWxseSB0byB0eXBlcyB0aGF0IGRvbid0IGhhdmUgYSBjb21wb3NlIGZ1bmN0aW9uIGRlZmluZWQuXG5cbi8vIEFkZCB0cmFuc2Zvcm0gYW5kIHRyYW5zZm9ybVggZnVuY3Rpb25zIGZvciBhbiBPVCB0eXBlIHdoaWNoIGhhc1xuLy8gdHJhbnNmb3JtQ29tcG9uZW50IGRlZmluZWQuICB0cmFuc2Zvcm1Db21wb25lbnQoZGVzdGluYXRpb24gYXJyYXksXG4vLyBjb21wb25lbnQsIG90aGVyIGNvbXBvbmVudCwgc2lkZSlcbm1vZHVsZS5leHBvcnRzID0gYm9vdHN0cmFwVHJhbnNmb3JtXG5mdW5jdGlvbiBib290c3RyYXBUcmFuc2Zvcm0odHlwZSwgdHJhbnNmb3JtQ29tcG9uZW50LCBjaGVja1ZhbGlkT3AsIGFwcGVuZCkge1xuICB2YXIgdHJhbnNmb3JtQ29tcG9uZW50WCA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBkZXN0TGVmdCwgZGVzdFJpZ2h0KSB7XG4gICAgdHJhbnNmb3JtQ29tcG9uZW50KGRlc3RMZWZ0LCBsZWZ0LCByaWdodCwgJ2xlZnQnKTtcbiAgICB0cmFuc2Zvcm1Db21wb25lbnQoZGVzdFJpZ2h0LCByaWdodCwgbGVmdCwgJ3JpZ2h0Jyk7XG4gIH07XG5cbiAgdmFyIHRyYW5zZm9ybVggPSB0eXBlLnRyYW5zZm9ybVggPSBmdW5jdGlvbihsZWZ0T3AsIHJpZ2h0T3ApIHtcbiAgICBjaGVja1ZhbGlkT3AobGVmdE9wKTtcbiAgICBjaGVja1ZhbGlkT3AocmlnaHRPcCk7XG4gICAgdmFyIG5ld1JpZ2h0T3AgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmlnaHRPcC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJpZ2h0Q29tcG9uZW50ID0gcmlnaHRPcFtpXTtcblxuICAgICAgLy8gR2VuZXJhdGUgbmV3TGVmdE9wIGJ5IGNvbXBvc2luZyBsZWZ0T3AgYnkgcmlnaHRDb21wb25lbnRcbiAgICAgIHZhciBuZXdMZWZ0T3AgPSBbXTtcbiAgICAgIHZhciBrID0gMDtcbiAgICAgIHdoaWxlIChrIDwgbGVmdE9wLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dEMgPSBbXTtcbiAgICAgICAgdHJhbnNmb3JtQ29tcG9uZW50WChsZWZ0T3Bba10sIHJpZ2h0Q29tcG9uZW50LCBuZXdMZWZ0T3AsIG5leHRDKTtcbiAgICAgICAgaysrO1xuXG4gICAgICAgIGlmIChuZXh0Qy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByaWdodENvbXBvbmVudCA9IG5leHRDWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRDLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGZvciAodmFyIGogPSBrOyBqIDwgbGVmdE9wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBhcHBlbmQobmV3TGVmdE9wLCBsZWZ0T3Bbal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByaWdodENvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVjdXJzZS5cbiAgICAgICAgICB2YXIgcGFpciA9IHRyYW5zZm9ybVgobGVmdE9wLnNsaWNlKGspLCBuZXh0Qyk7XG4gICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBwYWlyWzBdLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICBhcHBlbmQobmV3TGVmdE9wLCBwYWlyWzBdW2xdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBwYWlyWzFdLmxlbmd0aDsgcisrKSB7XG4gICAgICAgICAgICBhcHBlbmQobmV3UmlnaHRPcCwgcGFpclsxXVtyXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJpZ2h0Q29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmlnaHRDb21wb25lbnQgIT0gbnVsbCkge1xuICAgICAgICBhcHBlbmQobmV3UmlnaHRPcCwgcmlnaHRDb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgbGVmdE9wID0gbmV3TGVmdE9wO1xuICAgIH1cbiAgICByZXR1cm4gW2xlZnRPcCwgbmV3UmlnaHRPcF07XG4gIH07XG5cbiAgLy8gVHJhbnNmb3JtcyBvcCB3aXRoIHNwZWNpZmllZCB0eXBlICgnbGVmdCcgb3IgJ3JpZ2h0JykgYnkgb3RoZXJPcC5cbiAgdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbihvcCwgb3RoZXJPcCwgdHlwZSkge1xuICAgIGlmICghKHR5cGUgPT09ICdsZWZ0JyB8fCB0eXBlID09PSAncmlnaHQnKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgbXVzdCBiZSAnbGVmdCcgb3IgJ3JpZ2h0J1wiKTtcblxuICAgIGlmIChvdGhlck9wLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG9wO1xuXG4gICAgaWYgKG9wLmxlbmd0aCA9PT0gMSAmJiBvdGhlck9wLmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1Db21wb25lbnQoW10sIG9wWzBdLCBvdGhlck9wWzBdLCB0eXBlKTtcblxuICAgIGlmICh0eXBlID09PSAnbGVmdCcpXG4gICAgICByZXR1cm4gdHJhbnNmb3JtWChvcCwgb3RoZXJPcClbMF07XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRyYW5zZm9ybVgob3RoZXJPcCwgb3ApWzFdO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ot-json0/lib/bootstrapTransform.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ot-json0/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/ot-json0/lib/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Only the JSON type is exported, because the text type is deprecated\n// otherwise. (If you want to use it somewhere, you're welcome to pull it out\n// into a separate module that json0 can depend on).\n\nmodule.exports = {\n  type: __webpack_require__(/*! ./json0 */ \"(ssr)/./node_modules/ot-json0/lib/json0.js\")\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3QtanNvbjAvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsbUJBQU8sQ0FBQywyREFBUztBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL2RheTlfY29sbGFib3JhdGl2ZV9lZGl0b3IvLi9ub2RlX21vZHVsZXMvb3QtanNvbjAvbGliL2luZGV4LmpzPzk5ZDciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gT25seSB0aGUgSlNPTiB0eXBlIGlzIGV4cG9ydGVkLCBiZWNhdXNlIHRoZSB0ZXh0IHR5cGUgaXMgZGVwcmVjYXRlZFxuLy8gb3RoZXJ3aXNlLiAoSWYgeW91IHdhbnQgdG8gdXNlIGl0IHNvbWV3aGVyZSwgeW91J3JlIHdlbGNvbWUgdG8gcHVsbCBpdCBvdXRcbi8vIGludG8gYSBzZXBhcmF0ZSBtb2R1bGUgdGhhdCBqc29uMCBjYW4gZGVwZW5kIG9uKS5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHR5cGU6IHJlcXVpcmUoJy4vanNvbjAnKVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ot-json0/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ot-json0/lib/json0.js":
/*!********************************************!*\
  !*** ./node_modules/ot-json0/lib/json0.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n This is the implementation of the JSON OT type.\n\n Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations\n\n Note: This is being made obsolete. It will soon be replaced by the JSON2 type.\n*/\n\n/**\n * UTILITY FUNCTIONS\n */\n\n/**\n * Checks if the passed object is an Array instance. Can't use Array.isArray\n * yet because its not supported on IE8.\n *\n * @param obj\n * @returns {boolean}\n */\nvar isArray = function(obj) {\n  return Object.prototype.toString.call(obj) == '[object Array]';\n};\n\n/**\n * Checks if the passed object is an Object instance.\n * No function call (fast) version\n *\n * @param obj\n * @returns {boolean}\n */\nvar isObject = function(obj) {\n  return (!!obj) && (obj.constructor === Object);\n};\n\n/**\n * Clones the passed object using JSON serialization (which is slow).\n *\n * hax, copied from test/types/json. Apparently this is still the fastest way\n * to deep clone an object, assuming we have browser support for JSON.  @see\n * http://jsperf.com/cloning-an-object/12\n */\nvar clone = function(o) {\n  return JSON.parse(JSON.stringify(o));\n};\n\n/**\n * JSON OT Type\n * @type {*}\n */\nvar json = {\n  name: 'json0',\n  uri: 'http://sharejs.org/types/JSONv0'\n};\n\n// You can register another OT type as a subtype in a JSON document using\n// the following function. This allows another type to handle certain\n// operations instead of the builtin JSON type.\nvar subtypes = {};\njson.registerSubtype = function(subtype) {\n  subtypes[subtype.name] = subtype;\n};\n\njson.create = function(data) {\n  // Null instead of undefined if you don't pass an argument.\n  return data === undefined ? null : clone(data);\n};\n\njson.invertComponent = function(c) {\n  var c_ = {p: c.p};\n\n  // handle subtype ops\n  if (c.t && subtypes[c.t]) {\n    c_.t = c.t;\n    c_.o = subtypes[c.t].invert(c.o);\n  }\n\n  if (c.si !== void 0) c_.sd = c.si;\n  if (c.sd !== void 0) c_.si = c.sd;\n  if (c.oi !== void 0) c_.od = c.oi;\n  if (c.od !== void 0) c_.oi = c.od;\n  if (c.li !== void 0) c_.ld = c.li;\n  if (c.ld !== void 0) c_.li = c.ld;\n  if (c.na !== void 0) c_.na = -c.na;\n\n  if (c.lm !== void 0) {\n    c_.lm = c.p[c.p.length-1];\n    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);\n  }\n\n  return c_;\n};\n\njson.invert = function(op) {\n  var op_ = op.slice().reverse();\n  var iop = [];\n  for (var i = 0; i < op_.length; i++) {\n    iop.push(json.invertComponent(op_[i]));\n  }\n  return iop;\n};\n\njson.checkValidOp = function(op) {\n  for (var i = 0; i < op.length; i++) {\n    if (!isArray(op[i].p)) throw new Error('Missing path');\n  }\n};\n\njson.checkList = function(elem) {\n  if (!isArray(elem))\n    throw new Error('Referenced element not a list');\n};\n\njson.checkObj = function(elem) {\n  if (!isObject(elem)) {\n    throw new Error(\"Referenced element not an object (it was \" + JSON.stringify(elem) + \")\");\n  }\n};\n\n// helper functions to convert old string ops to and from subtype ops\nfunction convertFromText(c) {\n  c.t = 'text0';\n  var o = {p: c.p.pop()};\n  if (c.si != null) o.i = c.si;\n  if (c.sd != null) o.d = c.sd;\n  c.o = [o];\n}\n\nfunction convertToText(c) {\n  c.p.push(c.o[0].p);\n  if (c.o[0].i != null) c.si = c.o[0].i;\n  if (c.o[0].d != null) c.sd = c.o[0].d;\n  delete c.t;\n  delete c.o;\n}\n\njson.apply = function(snapshot, op) {\n  json.checkValidOp(op);\n\n  op = clone(op);\n\n  var container = {\n    data: snapshot\n  };\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n\n    // convert old string ops to use subtype for backwards compatibility\n    if (c.si != null || c.sd != null)\n      convertFromText(c);\n\n    var parent = null;\n    var parentKey = null;\n    var elem = container;\n    var key = 'data';\n\n    for (var j = 0; j < c.p.length; j++) {\n      var p = c.p[j];\n\n      parent = elem;\n      parentKey = key;\n      elem = elem[key];\n      key = p;\n\n      if (parent == null)\n        throw new Error('Path invalid');\n    }\n\n    // handle subtype ops\n    if (c.t && c.o !== void 0 && subtypes[c.t]) {\n      elem[key] = subtypes[c.t].apply(elem[key], c.o);\n\n    // Number add\n    } else if (c.na !== void 0) {\n      if (typeof elem[key] != 'number')\n        throw new Error('Referenced element not a number');\n\n      elem[key] += c.na;\n    }\n\n    // List replace\n    else if (c.li !== void 0 && c.ld !== void 0) {\n      json.checkList(elem);\n      // Should check the list element matches c.ld\n      elem[key] = c.li;\n    }\n\n    // List insert\n    else if (c.li !== void 0) {\n      json.checkList(elem);\n      elem.splice(key,0, c.li);\n    }\n\n    // List delete\n    else if (c.ld !== void 0) {\n      json.checkList(elem);\n      // Should check the list element matches c.ld here too.\n      elem.splice(key,1);\n    }\n\n    // List move\n    else if (c.lm !== void 0) {\n      json.checkList(elem);\n      if (c.lm != key) {\n        var e = elem[key];\n        // Remove it...\n        elem.splice(key,1);\n        // And insert it back.\n        elem.splice(c.lm,0,e);\n      }\n    }\n\n    // Object insert / replace\n    else if (c.oi !== void 0) {\n      json.checkObj(elem);\n\n      // Should check that elem[key] == c.od\n      elem[key] = c.oi;\n    }\n\n    // Object delete\n    else if (c.od !== void 0) {\n      json.checkObj(elem);\n\n      // Should check that elem[key] == c.od\n      delete elem[key];\n    }\n\n    else {\n      throw new Error('invalid / missing instruction in op');\n    }\n  }\n\n  return container.data;\n};\n\n// Helper to break an operation up into a bunch of small ops.\njson.shatter = function(op) {\n  var results = [];\n  for (var i = 0; i < op.length; i++) {\n    results.push([op[i]]);\n  }\n  return results;\n};\n\n// Helper for incrementally applying an operation to a snapshot. Calls yield\n// after each op component has been applied.\njson.incrementalApply = function(snapshot, op, _yield) {\n  for (var i = 0; i < op.length; i++) {\n    var smallOp = [op[i]];\n    snapshot = json.apply(snapshot, smallOp);\n    // I'd just call this yield, but thats a reserved keyword. Bah!\n    _yield(smallOp, snapshot);\n  }\n\n  return snapshot;\n};\n\n// Checks if two paths, p1 and p2 match.\nvar pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {\n  if (p1.length != p2.length)\n    return false;\n\n  for (var i = 0; i < p1.length; i++) {\n    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))\n      return false;\n  }\n\n  return true;\n};\n\njson.append = function(dest,c) {\n  c = clone(c);\n\n  if (dest.length === 0) {\n    dest.push(c);\n    return;\n  }\n\n  var last = dest[dest.length - 1];\n\n  // convert old string ops to use subtype for backwards compatibility\n  if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n    convertFromText(c);\n    convertFromText(last);\n  }\n\n  if (pathMatches(c.p, last.p)) {\n    // handle subtype ops\n    if (c.t && last.t && c.t === last.t && subtypes[c.t]) {\n      last.o = subtypes[c.t].compose(last.o, c.o);\n\n      // convert back to old string ops\n      if (c.si != null || c.sd != null) {\n        var p = c.p;\n        for (var i = 0; i < last.o.length - 1; i++) {\n          c.o = [last.o.pop()];\n          c.p = p.slice();\n          convertToText(c);\n          dest.push(c);\n        }\n\n        convertToText(last);\n      }\n    } else if (last.na != null && c.na != null) {\n      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};\n    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {\n      // insert immediately followed by delete becomes a noop.\n      if (last.ld !== undefined) {\n        // leave the delete part of the replace\n        delete last.li;\n      } else {\n        dest.pop();\n      }\n    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {\n      last.oi = c.oi;\n    } else if (last.oi !== undefined && c.od !== undefined) {\n      // The last path component inserted something that the new component deletes (or replaces).\n      // Just merge them.\n      if (c.oi !== undefined) {\n        last.oi = c.oi;\n      } else if (last.od !== undefined) {\n        delete last.oi;\n      } else {\n        // An insert directly followed by a delete turns into a no-op and can be removed.\n        dest.pop();\n      }\n    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {\n      // don't do anything\n    } else {\n      dest.push(c);\n    }\n  } else {\n    // convert string ops back\n    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n      convertToText(c);\n      convertToText(last);\n    }\n\n    dest.push(c);\n  }\n};\n\njson.compose = function(op1,op2) {\n  json.checkValidOp(op1);\n  json.checkValidOp(op2);\n\n  var newOp = clone(op1);\n\n  for (var i = 0; i < op2.length; i++) {\n    json.append(newOp,op2[i]);\n  }\n\n  return newOp;\n};\n\njson.normalize = function(op) {\n  var newOp = [];\n\n  op = isArray(op) ? op : [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = [];\n\n    json.append(newOp,c);\n  }\n\n  return newOp;\n};\n\n// Returns the common length of the paths of ops a and b\njson.commonLengthForOps = function(a, b) {\n  var alen = a.p.length;\n  var blen = b.p.length;\n  if (a.na != null || a.t)\n    alen++;\n\n  if (b.na != null || b.t)\n    blen++;\n\n  if (alen === 0) return -1;\n  if (blen === 0) return null;\n\n  alen--;\n  blen--;\n\n  for (var i = 0; i < alen; i++) {\n    var p = a.p[i];\n    if (i >= blen || p !== b.p[i])\n      return null;\n  }\n\n  return alen;\n};\n\n// Returns true if an op can affect the given path\njson.canOpAffectPath = function(op, path) {\n  return json.commonLengthForOps({p:path}, op) != null;\n};\n\n// transform c so it applies to a document with otherC applied.\njson.transformComponent = function(dest, c, otherC, type) {\n  c = clone(c);\n\n  var common = json.commonLengthForOps(otherC, c);\n  var common2 = json.commonLengthForOps(c, otherC);\n  var cplength = c.p.length;\n  var otherCplength = otherC.p.length;\n\n  if (c.na != null || c.t)\n    cplength++;\n\n  if (otherC.na != null || otherC.t)\n    otherCplength++;\n\n  // if c is deleting something, and that thing is changed by otherC, we need to\n  // update c to reflect that change for invertibility.\n  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {\n    if (c.ld !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.ld = json.apply(clone(c.ld),[oc]);\n    } else if (c.od !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.od = json.apply(clone(c.od),[oc]);\n    }\n  }\n\n  if (common != null) {\n    var commonOperand = cplength == otherCplength;\n\n    // backward compatibility for old string ops\n    var oc = otherC;\n    if ((c.si != null || c.sd != null) && (otherC.si != null || otherC.sd != null)) {\n      convertFromText(c);\n      oc = clone(otherC);\n      convertFromText(oc);\n    }\n\n    // handle subtype ops\n    if (oc.t && subtypes[oc.t]) {\n      if (c.t && c.t === oc.t) {\n        var res = subtypes[c.t].transform(c.o, oc.o, type);\n\n        // convert back to old string ops\n        if (c.si != null || c.sd != null) {\n          var p = c.p;\n          for (var i = 0; i < res.length; i++) {\n            c.o = [res[i]];\n            c.p = p.slice();\n            convertToText(c);\n            json.append(dest, c);\n          }\n        } else if (!isArray(res) || res.length > 0) {\n          c.o = res;\n          json.append(dest, c);\n        }\n\n        return dest;\n      }\n    }\n\n    // transform based on otherC\n    else if (otherC.na !== void 0) {\n      // this case is handled below\n    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {\n      if (otherC.p[common] === c.p[common]) {\n        // noop\n\n        if (!commonOperand) {\n          return dest;\n        } else if (c.ld !== void 0) {\n          // we're trying to delete the same element, -> noop\n          if (c.li !== void 0 && type === 'left') {\n            // we're both replacing one element with another. only one can survive\n            c.ld = clone(otherC.li);\n          } else {\n            return dest;\n          }\n        }\n      }\n    } else if (otherC.li !== void 0) {\n      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {\n        // in li vs. li, left wins.\n        if (type === 'right')\n          c.p[common]++;\n      } else if (otherC.p[common] <= c.p[common]) {\n        c.p[common]++;\n      }\n\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          // otherC edits the same list we edit\n          if (otherC.p[common] <= c.lm)\n            c.lm++;\n          // changing c.from is handled above.\n        }\n      }\n    } else if (otherC.ld !== void 0) {\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          if (otherC.p[common] === c.p[common]) {\n            // they deleted the thing we're trying to move\n            return dest;\n          }\n          // otherC edits the same list we edit\n          var p = otherC.p[common];\n          var from = c.p[common];\n          var to = c.lm;\n          if (p < to || (p === to && from < to))\n            c.lm--;\n\n        }\n      }\n\n      if (otherC.p[common] < c.p[common]) {\n        c.p[common]--;\n      } else if (otherC.p[common] === c.p[common]) {\n        if (otherCplength < cplength) {\n          // we're below the deleted element, so -> noop\n          return dest;\n        } else if (c.ld !== void 0) {\n          if (c.li !== void 0) {\n            // we're replacing, they're deleting. we become an insert.\n            delete c.ld;\n          } else {\n            // we're trying to delete the same element, -> noop\n            return dest;\n          }\n        }\n      }\n\n    } else if (otherC.lm !== void 0) {\n      if (c.lm !== void 0 && cplength === otherCplength) {\n        // lm vs lm, here we go!\n        var from = c.p[common];\n        var to = c.lm;\n        var otherFrom = otherC.p[common];\n        var otherTo = otherC.lm;\n        if (otherFrom !== otherTo) {\n          // if otherFrom == otherTo, we don't need to change our op.\n\n          // where did my thing go?\n          if (from === otherFrom) {\n            // they moved it! tie break.\n            if (type === 'left') {\n              c.p[common] = otherTo;\n              if (from === to) // ugh\n                c.lm = otherTo;\n            } else {\n              return dest;\n            }\n          } else {\n            // they moved around it\n            if (from > otherFrom) c.p[common]--;\n            if (from > otherTo) c.p[common]++;\n            else if (from === otherTo) {\n              if (otherFrom > otherTo) {\n                c.p[common]++;\n                if (from === to) // ugh, again\n                  c.lm++;\n              }\n            }\n\n            // step 2: where am i going to put it?\n            if (to > otherFrom) {\n              c.lm--;\n            } else if (to === otherFrom) {\n              if (to > from)\n                c.lm--;\n            }\n            if (to > otherTo) {\n              c.lm++;\n            } else if (to === otherTo) {\n              // if we're both moving in the same direction, tie break\n              if ((otherTo > otherFrom && to > from) ||\n                  (otherTo < otherFrom && to < from)) {\n                if (type === 'right') c.lm++;\n              } else {\n                if (to > from) c.lm++;\n                else if (to === otherFrom) c.lm--;\n              }\n            }\n          }\n        }\n      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {\n        // li\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n        if (p > from) c.p[common]--;\n        if (p > to) c.p[common]++;\n      } else {\n        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath\n        // the lm\n        //\n        // i.e. things care about where their item is after the move.\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n        if (p === from) {\n          c.p[common] = to;\n        } else {\n          if (p > from) c.p[common]--;\n          if (p > to) c.p[common]++;\n          else if (p === to && from > to) c.p[common]++;\n        }\n      }\n    }\n    else if (otherC.oi !== void 0 && otherC.od !== void 0) {\n      if (c.p[common] === otherC.p[common]) {\n        if (c.oi !== void 0 && commonOperand) {\n          // we inserted where someone else replaced\n          if (type === 'right') {\n            // left wins\n            return dest;\n          } else {\n            // we win, make our op replace what they inserted\n            c.od = otherC.oi;\n          }\n        } else {\n          // -> noop if the other component is deleting the same object (or any parent)\n          return dest;\n        }\n      }\n    } else if (otherC.oi !== void 0) {\n      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {\n        // left wins if we try to insert at the same place\n        if (type === 'left') {\n          json.append(dest,{p: c.p, od:otherC.oi});\n        } else {\n          return dest;\n        }\n      }\n    } else if (otherC.od !== void 0) {\n      if (c.p[common] == otherC.p[common]) {\n        if (!commonOperand)\n          return dest;\n        if (c.oi !== void 0) {\n          delete c.od;\n        } else {\n          return dest;\n        }\n      }\n    }\n  }\n\n  json.append(dest,c);\n  return dest;\n};\n\n__webpack_require__(/*! ./bootstrapTransform */ \"(ssr)/./node_modules/ot-json0/lib/bootstrapTransform.js\")(json, json.transformComponent, json.checkValidOp, json.append);\n\n/**\n * Register a subtype for string operations, using the text0 type.\n */\nvar text = __webpack_require__(/*! ./text0 */ \"(ssr)/./node_modules/ot-json0/lib/text0.js\");\n\njson.registerSubtype(text);\nmodule.exports = json;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3QtanNvbjAvbGliL2pzb24wLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGVBQWU7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTiwrQkFBK0I7QUFDL0IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFPLENBQUMscUZBQXNCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsMkRBQVM7O0FBRTVCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXk5X2NvbGxhYm9yYXRpdmVfZWRpdG9yLy4vbm9kZV9tb2R1bGVzL290LWpzb24wL2xpYi9qc29uMC5qcz8xZWFhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gVGhpcyBpcyB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIEpTT04gT1QgdHlwZS5cblxuIFNwZWMgaXMgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2pvc2VwaGcvU2hhcmVKUy93aWtpL0pTT04tT3BlcmF0aW9uc1xuXG4gTm90ZTogVGhpcyBpcyBiZWluZyBtYWRlIG9ic29sZXRlLiBJdCB3aWxsIHNvb24gYmUgcmVwbGFjZWQgYnkgdGhlIEpTT04yIHR5cGUuXG4qL1xuXG4vKipcbiAqIFVUSUxJVFkgRlVOQ1RJT05TXG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHBhc3NlZCBvYmplY3QgaXMgYW4gQXJyYXkgaW5zdGFuY2UuIENhbid0IHVzZSBBcnJheS5pc0FycmF5XG4gKiB5ZXQgYmVjYXVzZSBpdHMgbm90IHN1cHBvcnRlZCBvbiBJRTguXG4gKlxuICogQHBhcmFtIG9ialxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnZhciBpc0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHBhc3NlZCBvYmplY3QgaXMgYW4gT2JqZWN0IGluc3RhbmNlLlxuICogTm8gZnVuY3Rpb24gY2FsbCAoZmFzdCkgdmVyc2lvblxuICpcbiAqIEBwYXJhbSBvYmpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuICghIW9iaikgJiYgKG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcbn07XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBwYXNzZWQgb2JqZWN0IHVzaW5nIEpTT04gc2VyaWFsaXphdGlvbiAod2hpY2ggaXMgc2xvdykuXG4gKlxuICogaGF4LCBjb3BpZWQgZnJvbSB0ZXN0L3R5cGVzL2pzb24uIEFwcGFyZW50bHkgdGhpcyBpcyBzdGlsbCB0aGUgZmFzdGVzdCB3YXlcbiAqIHRvIGRlZXAgY2xvbmUgYW4gb2JqZWN0LCBhc3N1bWluZyB3ZSBoYXZlIGJyb3dzZXIgc3VwcG9ydCBmb3IgSlNPTi4gIEBzZWVcbiAqIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb25pbmctYW4tb2JqZWN0LzEyXG4gKi9cbnZhciBjbG9uZSA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobykpO1xufTtcblxuLyoqXG4gKiBKU09OIE9UIFR5cGVcbiAqIEB0eXBlIHsqfVxuICovXG52YXIganNvbiA9IHtcbiAgbmFtZTogJ2pzb24wJyxcbiAgdXJpOiAnaHR0cDovL3NoYXJlanMub3JnL3R5cGVzL0pTT052MCdcbn07XG5cbi8vIFlvdSBjYW4gcmVnaXN0ZXIgYW5vdGhlciBPVCB0eXBlIGFzIGEgc3VidHlwZSBpbiBhIEpTT04gZG9jdW1lbnQgdXNpbmdcbi8vIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb24uIFRoaXMgYWxsb3dzIGFub3RoZXIgdHlwZSB0byBoYW5kbGUgY2VydGFpblxuLy8gb3BlcmF0aW9ucyBpbnN0ZWFkIG9mIHRoZSBidWlsdGluIEpTT04gdHlwZS5cbnZhciBzdWJ0eXBlcyA9IHt9O1xuanNvbi5yZWdpc3RlclN1YnR5cGUgPSBmdW5jdGlvbihzdWJ0eXBlKSB7XG4gIHN1YnR5cGVzW3N1YnR5cGUubmFtZV0gPSBzdWJ0eXBlO1xufTtcblxuanNvbi5jcmVhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gIC8vIE51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQgaWYgeW91IGRvbid0IHBhc3MgYW4gYXJndW1lbnQuXG4gIHJldHVybiBkYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogY2xvbmUoZGF0YSk7XG59O1xuXG5qc29uLmludmVydENvbXBvbmVudCA9IGZ1bmN0aW9uKGMpIHtcbiAgdmFyIGNfID0ge3A6IGMucH07XG5cbiAgLy8gaGFuZGxlIHN1YnR5cGUgb3BzXG4gIGlmIChjLnQgJiYgc3VidHlwZXNbYy50XSkge1xuICAgIGNfLnQgPSBjLnQ7XG4gICAgY18ubyA9IHN1YnR5cGVzW2MudF0uaW52ZXJ0KGMubyk7XG4gIH1cblxuICBpZiAoYy5zaSAhPT0gdm9pZCAwKSBjXy5zZCA9IGMuc2k7XG4gIGlmIChjLnNkICE9PSB2b2lkIDApIGNfLnNpID0gYy5zZDtcbiAgaWYgKGMub2kgIT09IHZvaWQgMCkgY18ub2QgPSBjLm9pO1xuICBpZiAoYy5vZCAhPT0gdm9pZCAwKSBjXy5vaSA9IGMub2Q7XG4gIGlmIChjLmxpICE9PSB2b2lkIDApIGNfLmxkID0gYy5saTtcbiAgaWYgKGMubGQgIT09IHZvaWQgMCkgY18ubGkgPSBjLmxkO1xuICBpZiAoYy5uYSAhPT0gdm9pZCAwKSBjXy5uYSA9IC1jLm5hO1xuXG4gIGlmIChjLmxtICE9PSB2b2lkIDApIHtcbiAgICBjXy5sbSA9IGMucFtjLnAubGVuZ3RoLTFdO1xuICAgIGNfLnAgPSBjLnAuc2xpY2UoMCxjLnAubGVuZ3RoLTEpLmNvbmNhdChbYy5sbV0pO1xuICB9XG5cbiAgcmV0dXJuIGNfO1xufTtcblxuanNvbi5pbnZlcnQgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgb3BfID0gb3Auc2xpY2UoKS5yZXZlcnNlKCk7XG4gIHZhciBpb3AgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcF8ubGVuZ3RoOyBpKyspIHtcbiAgICBpb3AucHVzaChqc29uLmludmVydENvbXBvbmVudChvcF9baV0pKTtcbiAgfVxuICByZXR1cm4gaW9wO1xufTtcblxuanNvbi5jaGVja1ZhbGlkT3AgPSBmdW5jdGlvbihvcCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFpc0FycmF5KG9wW2ldLnApKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcGF0aCcpO1xuICB9XG59O1xuXG5qc29uLmNoZWNrTGlzdCA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgaWYgKCFpc0FycmF5KGVsZW0pKVxuICAgIHRocm93IG5ldyBFcnJvcignUmVmZXJlbmNlZCBlbGVtZW50IG5vdCBhIGxpc3QnKTtcbn07XG5cbmpzb24uY2hlY2tPYmogPSBmdW5jdGlvbihlbGVtKSB7XG4gIGlmICghaXNPYmplY3QoZWxlbSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWZlcmVuY2VkIGVsZW1lbnQgbm90IGFuIG9iamVjdCAoaXQgd2FzIFwiICsgSlNPTi5zdHJpbmdpZnkoZWxlbSkgKyBcIilcIik7XG4gIH1cbn07XG5cbi8vIGhlbHBlciBmdW5jdGlvbnMgdG8gY29udmVydCBvbGQgc3RyaW5nIG9wcyB0byBhbmQgZnJvbSBzdWJ0eXBlIG9wc1xuZnVuY3Rpb24gY29udmVydEZyb21UZXh0KGMpIHtcbiAgYy50ID0gJ3RleHQwJztcbiAgdmFyIG8gPSB7cDogYy5wLnBvcCgpfTtcbiAgaWYgKGMuc2kgIT0gbnVsbCkgby5pID0gYy5zaTtcbiAgaWYgKGMuc2QgIT0gbnVsbCkgby5kID0gYy5zZDtcbiAgYy5vID0gW29dO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9UZXh0KGMpIHtcbiAgYy5wLnB1c2goYy5vWzBdLnApO1xuICBpZiAoYy5vWzBdLmkgIT0gbnVsbCkgYy5zaSA9IGMub1swXS5pO1xuICBpZiAoYy5vWzBdLmQgIT0gbnVsbCkgYy5zZCA9IGMub1swXS5kO1xuICBkZWxldGUgYy50O1xuICBkZWxldGUgYy5vO1xufVxuXG5qc29uLmFwcGx5ID0gZnVuY3Rpb24oc25hcHNob3QsIG9wKSB7XG4gIGpzb24uY2hlY2tWYWxpZE9wKG9wKTtcblxuICBvcCA9IGNsb25lKG9wKTtcblxuICB2YXIgY29udGFpbmVyID0ge1xuICAgIGRhdGE6IHNuYXBzaG90XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gb3BbaV07XG5cbiAgICAvLyBjb252ZXJ0IG9sZCBzdHJpbmcgb3BzIHRvIHVzZSBzdWJ0eXBlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIGlmIChjLnNpICE9IG51bGwgfHwgYy5zZCAhPSBudWxsKVxuICAgICAgY29udmVydEZyb21UZXh0KGMpO1xuXG4gICAgdmFyIHBhcmVudCA9IG51bGw7XG4gICAgdmFyIHBhcmVudEtleSA9IG51bGw7XG4gICAgdmFyIGVsZW0gPSBjb250YWluZXI7XG4gICAgdmFyIGtleSA9ICdkYXRhJztcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYy5wLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcCA9IGMucFtqXTtcblxuICAgICAgcGFyZW50ID0gZWxlbTtcbiAgICAgIHBhcmVudEtleSA9IGtleTtcbiAgICAgIGVsZW0gPSBlbGVtW2tleV07XG4gICAgICBrZXkgPSBwO1xuXG4gICAgICBpZiAocGFyZW50ID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHN1YnR5cGUgb3BzXG4gICAgaWYgKGMudCAmJiBjLm8gIT09IHZvaWQgMCAmJiBzdWJ0eXBlc1tjLnRdKSB7XG4gICAgICBlbGVtW2tleV0gPSBzdWJ0eXBlc1tjLnRdLmFwcGx5KGVsZW1ba2V5XSwgYy5vKTtcblxuICAgIC8vIE51bWJlciBhZGRcbiAgICB9IGVsc2UgaWYgKGMubmEgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtW2tleV0gIT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVmZXJlbmNlZCBlbGVtZW50IG5vdCBhIG51bWJlcicpO1xuXG4gICAgICBlbGVtW2tleV0gKz0gYy5uYTtcbiAgICB9XG5cbiAgICAvLyBMaXN0IHJlcGxhY2VcbiAgICBlbHNlIGlmIChjLmxpICE9PSB2b2lkIDAgJiYgYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrTGlzdChlbGVtKTtcbiAgICAgIC8vIFNob3VsZCBjaGVjayB0aGUgbGlzdCBlbGVtZW50IG1hdGNoZXMgYy5sZFxuICAgICAgZWxlbVtrZXldID0gYy5saTtcbiAgICB9XG5cbiAgICAvLyBMaXN0IGluc2VydFxuICAgIGVsc2UgaWYgKGMubGkgIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja0xpc3QoZWxlbSk7XG4gICAgICBlbGVtLnNwbGljZShrZXksMCwgYy5saSk7XG4gICAgfVxuXG4gICAgLy8gTGlzdCBkZWxldGVcbiAgICBlbHNlIGlmIChjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgIGpzb24uY2hlY2tMaXN0KGVsZW0pO1xuICAgICAgLy8gU2hvdWxkIGNoZWNrIHRoZSBsaXN0IGVsZW1lbnQgbWF0Y2hlcyBjLmxkIGhlcmUgdG9vLlxuICAgICAgZWxlbS5zcGxpY2Uoa2V5LDEpO1xuICAgIH1cblxuICAgIC8vIExpc3QgbW92ZVxuICAgIGVsc2UgaWYgKGMubG0gIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja0xpc3QoZWxlbSk7XG4gICAgICBpZiAoYy5sbSAhPSBrZXkpIHtcbiAgICAgICAgdmFyIGUgPSBlbGVtW2tleV07XG4gICAgICAgIC8vIFJlbW92ZSBpdC4uLlxuICAgICAgICBlbGVtLnNwbGljZShrZXksMSk7XG4gICAgICAgIC8vIEFuZCBpbnNlcnQgaXQgYmFjay5cbiAgICAgICAgZWxlbS5zcGxpY2UoYy5sbSwwLGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9iamVjdCBpbnNlcnQgLyByZXBsYWNlXG4gICAgZWxzZSBpZiAoYy5vaSAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrT2JqKGVsZW0pO1xuXG4gICAgICAvLyBTaG91bGQgY2hlY2sgdGhhdCBlbGVtW2tleV0gPT0gYy5vZFxuICAgICAgZWxlbVtrZXldID0gYy5vaTtcbiAgICB9XG5cbiAgICAvLyBPYmplY3QgZGVsZXRlXG4gICAgZWxzZSBpZiAoYy5vZCAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrT2JqKGVsZW0pO1xuXG4gICAgICAvLyBTaG91bGQgY2hlY2sgdGhhdCBlbGVtW2tleV0gPT0gYy5vZFxuICAgICAgZGVsZXRlIGVsZW1ba2V5XTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCAvIG1pc3NpbmcgaW5zdHJ1Y3Rpb24gaW4gb3AnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyLmRhdGE7XG59O1xuXG4vLyBIZWxwZXIgdG8gYnJlYWsgYW4gb3BlcmF0aW9uIHVwIGludG8gYSBidW5jaCBvZiBzbWFsbCBvcHMuXG5qc29uLnNoYXR0ZXIgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0cy5wdXNoKFtvcFtpXV0pO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gSGVscGVyIGZvciBpbmNyZW1lbnRhbGx5IGFwcGx5aW5nIGFuIG9wZXJhdGlvbiB0byBhIHNuYXBzaG90LiBDYWxscyB5aWVsZFxuLy8gYWZ0ZXIgZWFjaCBvcCBjb21wb25lbnQgaGFzIGJlZW4gYXBwbGllZC5cbmpzb24uaW5jcmVtZW50YWxBcHBseSA9IGZ1bmN0aW9uKHNuYXBzaG90LCBvcCwgX3lpZWxkKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc21hbGxPcCA9IFtvcFtpXV07XG4gICAgc25hcHNob3QgPSBqc29uLmFwcGx5KHNuYXBzaG90LCBzbWFsbE9wKTtcbiAgICAvLyBJJ2QganVzdCBjYWxsIHRoaXMgeWllbGQsIGJ1dCB0aGF0cyBhIHJlc2VydmVkIGtleXdvcmQuIEJhaCFcbiAgICBfeWllbGQoc21hbGxPcCwgc25hcHNob3QpO1xuICB9XG5cbiAgcmV0dXJuIHNuYXBzaG90O1xufTtcblxuLy8gQ2hlY2tzIGlmIHR3byBwYXRocywgcDEgYW5kIHAyIG1hdGNoLlxudmFyIHBhdGhNYXRjaGVzID0ganNvbi5wYXRoTWF0Y2hlcyA9IGZ1bmN0aW9uKHAxLCBwMiwgaWdub3JlTGFzdCkge1xuICBpZiAocDEubGVuZ3RoICE9IHAyLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwMS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwMVtpXSAhPT0gcDJbaV0gJiYgKCFpZ25vcmVMYXN0IHx8IGkgIT09IHAxLmxlbmd0aCAtIDEpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5qc29uLmFwcGVuZCA9IGZ1bmN0aW9uKGRlc3QsYykge1xuICBjID0gY2xvbmUoYyk7XG5cbiAgaWYgKGRlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgZGVzdC5wdXNoKGMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsYXN0ID0gZGVzdFtkZXN0Lmxlbmd0aCAtIDFdO1xuXG4gIC8vIGNvbnZlcnQgb2xkIHN0cmluZyBvcHMgdG8gdXNlIHN1YnR5cGUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIGlmICgoYy5zaSAhPSBudWxsIHx8IGMuc2QgIT0gbnVsbCkgJiYgKGxhc3Quc2kgIT0gbnVsbCB8fCBsYXN0LnNkICE9IG51bGwpKSB7XG4gICAgY29udmVydEZyb21UZXh0KGMpO1xuICAgIGNvbnZlcnRGcm9tVGV4dChsYXN0KTtcbiAgfVxuXG4gIGlmIChwYXRoTWF0Y2hlcyhjLnAsIGxhc3QucCkpIHtcbiAgICAvLyBoYW5kbGUgc3VidHlwZSBvcHNcbiAgICBpZiAoYy50ICYmIGxhc3QudCAmJiBjLnQgPT09IGxhc3QudCAmJiBzdWJ0eXBlc1tjLnRdKSB7XG4gICAgICBsYXN0Lm8gPSBzdWJ0eXBlc1tjLnRdLmNvbXBvc2UobGFzdC5vLCBjLm8pO1xuXG4gICAgICAvLyBjb252ZXJ0IGJhY2sgdG8gb2xkIHN0cmluZyBvcHNcbiAgICAgIGlmIChjLnNpICE9IG51bGwgfHwgYy5zZCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBwID0gYy5wO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3Quby5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBjLm8gPSBbbGFzdC5vLnBvcCgpXTtcbiAgICAgICAgICBjLnAgPSBwLnNsaWNlKCk7XG4gICAgICAgICAgY29udmVydFRvVGV4dChjKTtcbiAgICAgICAgICBkZXN0LnB1c2goYyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb252ZXJ0VG9UZXh0KGxhc3QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGFzdC5uYSAhPSBudWxsICYmIGMubmEgIT0gbnVsbCkge1xuICAgICAgZGVzdFtkZXN0Lmxlbmd0aCAtIDFdID0ge3A6IGxhc3QucCwgbmE6IGxhc3QubmEgKyBjLm5hfTtcbiAgICB9IGVsc2UgaWYgKGxhc3QubGkgIT09IHVuZGVmaW5lZCAmJiBjLmxpID09PSB1bmRlZmluZWQgJiYgYy5sZCA9PT0gbGFzdC5saSkge1xuICAgICAgLy8gaW5zZXJ0IGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGRlbGV0ZSBiZWNvbWVzIGEgbm9vcC5cbiAgICAgIGlmIChsYXN0LmxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gbGVhdmUgdGhlIGRlbGV0ZSBwYXJ0IG9mIHRoZSByZXBsYWNlXG4gICAgICAgIGRlbGV0ZSBsYXN0LmxpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzdC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxhc3Qub2QgIT09IHVuZGVmaW5lZCAmJiBsYXN0Lm9pID09PSB1bmRlZmluZWQgJiYgYy5vaSAhPT0gdW5kZWZpbmVkICYmIGMub2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGFzdC5vaSA9IGMub2k7XG4gICAgfSBlbHNlIGlmIChsYXN0Lm9pICE9PSB1bmRlZmluZWQgJiYgYy5vZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGUgbGFzdCBwYXRoIGNvbXBvbmVudCBpbnNlcnRlZCBzb21ldGhpbmcgdGhhdCB0aGUgbmV3IGNvbXBvbmVudCBkZWxldGVzIChvciByZXBsYWNlcykuXG4gICAgICAvLyBKdXN0IG1lcmdlIHRoZW0uXG4gICAgICBpZiAoYy5vaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxhc3Qub2kgPSBjLm9pO1xuICAgICAgfSBlbHNlIGlmIChsYXN0Lm9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIGxhc3Qub2k7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbiBpbnNlcnQgZGlyZWN0bHkgZm9sbG93ZWQgYnkgYSBkZWxldGUgdHVybnMgaW50byBhIG5vLW9wIGFuZCBjYW4gYmUgcmVtb3ZlZC5cbiAgICAgICAgZGVzdC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGMubG0gIT09IHVuZGVmaW5lZCAmJiBjLnBbYy5wLmxlbmd0aCAtIDFdID09PSBjLmxtKSB7XG4gICAgICAvLyBkb24ndCBkbyBhbnl0aGluZ1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0LnB1c2goYyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbnZlcnQgc3RyaW5nIG9wcyBiYWNrXG4gICAgaWYgKChjLnNpICE9IG51bGwgfHwgYy5zZCAhPSBudWxsKSAmJiAobGFzdC5zaSAhPSBudWxsIHx8IGxhc3Quc2QgIT0gbnVsbCkpIHtcbiAgICAgIGNvbnZlcnRUb1RleHQoYyk7XG4gICAgICBjb252ZXJ0VG9UZXh0KGxhc3QpO1xuICAgIH1cblxuICAgIGRlc3QucHVzaChjKTtcbiAgfVxufTtcblxuanNvbi5jb21wb3NlID0gZnVuY3Rpb24ob3AxLG9wMikge1xuICBqc29uLmNoZWNrVmFsaWRPcChvcDEpO1xuICBqc29uLmNoZWNrVmFsaWRPcChvcDIpO1xuXG4gIHZhciBuZXdPcCA9IGNsb25lKG9wMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcDIubGVuZ3RoOyBpKyspIHtcbiAgICBqc29uLmFwcGVuZChuZXdPcCxvcDJbaV0pO1xuICB9XG5cbiAgcmV0dXJuIG5ld09wO1xufTtcblxuanNvbi5ub3JtYWxpemUgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgbmV3T3AgPSBbXTtcblxuICBvcCA9IGlzQXJyYXkob3ApID8gb3AgOiBbb3BdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IG9wW2ldO1xuICAgIGlmIChjLnAgPT0gbnVsbCkgYy5wID0gW107XG5cbiAgICBqc29uLmFwcGVuZChuZXdPcCxjKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPcDtcbn07XG5cbi8vIFJldHVybnMgdGhlIGNvbW1vbiBsZW5ndGggb2YgdGhlIHBhdGhzIG9mIG9wcyBhIGFuZCBiXG5qc29uLmNvbW1vbkxlbmd0aEZvck9wcyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGFsZW4gPSBhLnAubGVuZ3RoO1xuICB2YXIgYmxlbiA9IGIucC5sZW5ndGg7XG4gIGlmIChhLm5hICE9IG51bGwgfHwgYS50KVxuICAgIGFsZW4rKztcblxuICBpZiAoYi5uYSAhPSBudWxsIHx8IGIudClcbiAgICBibGVuKys7XG5cbiAgaWYgKGFsZW4gPT09IDApIHJldHVybiAtMTtcbiAgaWYgKGJsZW4gPT09IDApIHJldHVybiBudWxsO1xuXG4gIGFsZW4tLTtcbiAgYmxlbi0tO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxlbjsgaSsrKSB7XG4gICAgdmFyIHAgPSBhLnBbaV07XG4gICAgaWYgKGkgPj0gYmxlbiB8fCBwICE9PSBiLnBbaV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBhbGVuO1xufTtcblxuLy8gUmV0dXJucyB0cnVlIGlmIGFuIG9wIGNhbiBhZmZlY3QgdGhlIGdpdmVuIHBhdGhcbmpzb24uY2FuT3BBZmZlY3RQYXRoID0gZnVuY3Rpb24ob3AsIHBhdGgpIHtcbiAgcmV0dXJuIGpzb24uY29tbW9uTGVuZ3RoRm9yT3BzKHtwOnBhdGh9LCBvcCkgIT0gbnVsbDtcbn07XG5cbi8vIHRyYW5zZm9ybSBjIHNvIGl0IGFwcGxpZXMgdG8gYSBkb2N1bWVudCB3aXRoIG90aGVyQyBhcHBsaWVkLlxuanNvbi50cmFuc2Zvcm1Db21wb25lbnQgPSBmdW5jdGlvbihkZXN0LCBjLCBvdGhlckMsIHR5cGUpIHtcbiAgYyA9IGNsb25lKGMpO1xuXG4gIHZhciBjb21tb24gPSBqc29uLmNvbW1vbkxlbmd0aEZvck9wcyhvdGhlckMsIGMpO1xuICB2YXIgY29tbW9uMiA9IGpzb24uY29tbW9uTGVuZ3RoRm9yT3BzKGMsIG90aGVyQyk7XG4gIHZhciBjcGxlbmd0aCA9IGMucC5sZW5ndGg7XG4gIHZhciBvdGhlckNwbGVuZ3RoID0gb3RoZXJDLnAubGVuZ3RoO1xuXG4gIGlmIChjLm5hICE9IG51bGwgfHwgYy50KVxuICAgIGNwbGVuZ3RoKys7XG5cbiAgaWYgKG90aGVyQy5uYSAhPSBudWxsIHx8IG90aGVyQy50KVxuICAgIG90aGVyQ3BsZW5ndGgrKztcblxuICAvLyBpZiBjIGlzIGRlbGV0aW5nIHNvbWV0aGluZywgYW5kIHRoYXQgdGhpbmcgaXMgY2hhbmdlZCBieSBvdGhlckMsIHdlIG5lZWQgdG9cbiAgLy8gdXBkYXRlIGMgdG8gcmVmbGVjdCB0aGF0IGNoYW5nZSBmb3IgaW52ZXJ0aWJpbGl0eS5cbiAgaWYgKGNvbW1vbjIgIT0gbnVsbCAmJiBvdGhlckNwbGVuZ3RoID4gY3BsZW5ndGggJiYgYy5wW2NvbW1vbjJdID09IG90aGVyQy5wW2NvbW1vbjJdKSB7XG4gICAgaWYgKGMubGQgIT09IHZvaWQgMCkge1xuICAgICAgdmFyIG9jID0gY2xvbmUob3RoZXJDKTtcbiAgICAgIG9jLnAgPSBvYy5wLnNsaWNlKGNwbGVuZ3RoKTtcbiAgICAgIGMubGQgPSBqc29uLmFwcGx5KGNsb25lKGMubGQpLFtvY10pO1xuICAgIH0gZWxzZSBpZiAoYy5vZCAhPT0gdm9pZCAwKSB7XG4gICAgICB2YXIgb2MgPSBjbG9uZShvdGhlckMpO1xuICAgICAgb2MucCA9IG9jLnAuc2xpY2UoY3BsZW5ndGgpO1xuICAgICAgYy5vZCA9IGpzb24uYXBwbHkoY2xvbmUoYy5vZCksW29jXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbW1vbiAhPSBudWxsKSB7XG4gICAgdmFyIGNvbW1vbk9wZXJhbmQgPSBjcGxlbmd0aCA9PSBvdGhlckNwbGVuZ3RoO1xuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSBmb3Igb2xkIHN0cmluZyBvcHNcbiAgICB2YXIgb2MgPSBvdGhlckM7XG4gICAgaWYgKChjLnNpICE9IG51bGwgfHwgYy5zZCAhPSBudWxsKSAmJiAob3RoZXJDLnNpICE9IG51bGwgfHwgb3RoZXJDLnNkICE9IG51bGwpKSB7XG4gICAgICBjb252ZXJ0RnJvbVRleHQoYyk7XG4gICAgICBvYyA9IGNsb25lKG90aGVyQyk7XG4gICAgICBjb252ZXJ0RnJvbVRleHQob2MpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBzdWJ0eXBlIG9wc1xuICAgIGlmIChvYy50ICYmIHN1YnR5cGVzW29jLnRdKSB7XG4gICAgICBpZiAoYy50ICYmIGMudCA9PT0gb2MudCkge1xuICAgICAgICB2YXIgcmVzID0gc3VidHlwZXNbYy50XS50cmFuc2Zvcm0oYy5vLCBvYy5vLCB0eXBlKTtcblxuICAgICAgICAvLyBjb252ZXJ0IGJhY2sgdG8gb2xkIHN0cmluZyBvcHNcbiAgICAgICAgaWYgKGMuc2kgIT0gbnVsbCB8fCBjLnNkICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgcCA9IGMucDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYy5vID0gW3Jlc1tpXV07XG4gICAgICAgICAgICBjLnAgPSBwLnNsaWNlKCk7XG4gICAgICAgICAgICBjb252ZXJ0VG9UZXh0KGMpO1xuICAgICAgICAgICAganNvbi5hcHBlbmQoZGVzdCwgYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc0FycmF5KHJlcykgfHwgcmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjLm8gPSByZXM7XG4gICAgICAgICAganNvbi5hcHBlbmQoZGVzdCwgYyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0cmFuc2Zvcm0gYmFzZWQgb24gb3RoZXJDXG4gICAgZWxzZSBpZiAob3RoZXJDLm5hICE9PSB2b2lkIDApIHtcbiAgICAgIC8vIHRoaXMgY2FzZSBpcyBoYW5kbGVkIGJlbG93XG4gICAgfSBlbHNlIGlmIChvdGhlckMubGkgIT09IHZvaWQgMCAmJiBvdGhlckMubGQgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKG90aGVyQy5wW2NvbW1vbl0gPT09IGMucFtjb21tb25dKSB7XG4gICAgICAgIC8vIG5vb3BcblxuICAgICAgICBpZiAoIWNvbW1vbk9wZXJhbmQpIHtcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgfSBlbHNlIGlmIChjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAvLyB3ZSdyZSB0cnlpbmcgdG8gZGVsZXRlIHRoZSBzYW1lIGVsZW1lbnQsIC0+IG5vb3BcbiAgICAgICAgICBpZiAoYy5saSAhPT0gdm9pZCAwICYmIHR5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgLy8gd2UncmUgYm90aCByZXBsYWNpbmcgb25lIGVsZW1lbnQgd2l0aCBhbm90aGVyLiBvbmx5IG9uZSBjYW4gc3Vydml2ZVxuICAgICAgICAgICAgYy5sZCA9IGNsb25lKG90aGVyQy5saSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXJDLmxpICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLmxpICE9PSB2b2lkIDAgJiYgYy5sZCA9PT0gdW5kZWZpbmVkICYmIGNvbW1vbk9wZXJhbmQgJiYgYy5wW2NvbW1vbl0gPT09IG90aGVyQy5wW2NvbW1vbl0pIHtcbiAgICAgICAgLy8gaW4gbGkgdnMuIGxpLCBsZWZ0IHdpbnMuXG4gICAgICAgIGlmICh0eXBlID09PSAncmlnaHQnKVxuICAgICAgICAgIGMucFtjb21tb25dKys7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyQy5wW2NvbW1vbl0gPD0gYy5wW2NvbW1vbl0pIHtcbiAgICAgICAgYy5wW2NvbW1vbl0rKztcbiAgICAgIH1cblxuICAgICAgaWYgKGMubG0gIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAgIC8vIG90aGVyQyBlZGl0cyB0aGUgc2FtZSBsaXN0IHdlIGVkaXRcbiAgICAgICAgICBpZiAob3RoZXJDLnBbY29tbW9uXSA8PSBjLmxtKVxuICAgICAgICAgICAgYy5sbSsrO1xuICAgICAgICAgIC8vIGNoYW5naW5nIGMuZnJvbSBpcyBoYW5kbGVkIGFib3ZlLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvdGhlckMubGQgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMubG0gIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAgIGlmIChvdGhlckMucFtjb21tb25dID09PSBjLnBbY29tbW9uXSkge1xuICAgICAgICAgICAgLy8gdGhleSBkZWxldGVkIHRoZSB0aGluZyB3ZSdyZSB0cnlpbmcgdG8gbW92ZVxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG90aGVyQyBlZGl0cyB0aGUgc2FtZSBsaXN0IHdlIGVkaXRcbiAgICAgICAgICB2YXIgcCA9IG90aGVyQy5wW2NvbW1vbl07XG4gICAgICAgICAgdmFyIGZyb20gPSBjLnBbY29tbW9uXTtcbiAgICAgICAgICB2YXIgdG8gPSBjLmxtO1xuICAgICAgICAgIGlmIChwIDwgdG8gfHwgKHAgPT09IHRvICYmIGZyb20gPCB0bykpXG4gICAgICAgICAgICBjLmxtLS07XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3RoZXJDLnBbY29tbW9uXSA8IGMucFtjb21tb25dKSB7XG4gICAgICAgIGMucFtjb21tb25dLS07XG4gICAgICB9IGVsc2UgaWYgKG90aGVyQy5wW2NvbW1vbl0gPT09IGMucFtjb21tb25dKSB7XG4gICAgICAgIGlmIChvdGhlckNwbGVuZ3RoIDwgY3BsZW5ndGgpIHtcbiAgICAgICAgICAvLyB3ZSdyZSBiZWxvdyB0aGUgZGVsZXRlZCBlbGVtZW50LCBzbyAtPiBub29wXG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgaWYgKGMubGkgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgLy8gd2UncmUgcmVwbGFjaW5nLCB0aGV5J3JlIGRlbGV0aW5nLiB3ZSBiZWNvbWUgYW4gaW5zZXJ0LlxuICAgICAgICAgICAgZGVsZXRlIGMubGQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlJ3JlIHRyeWluZyB0byBkZWxldGUgdGhlIHNhbWUgZWxlbWVudCwgLT4gbm9vcFxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKG90aGVyQy5sbSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoYy5sbSAhPT0gdm9pZCAwICYmIGNwbGVuZ3RoID09PSBvdGhlckNwbGVuZ3RoKSB7XG4gICAgICAgIC8vIGxtIHZzIGxtLCBoZXJlIHdlIGdvIVxuICAgICAgICB2YXIgZnJvbSA9IGMucFtjb21tb25dO1xuICAgICAgICB2YXIgdG8gPSBjLmxtO1xuICAgICAgICB2YXIgb3RoZXJGcm9tID0gb3RoZXJDLnBbY29tbW9uXTtcbiAgICAgICAgdmFyIG90aGVyVG8gPSBvdGhlckMubG07XG4gICAgICAgIGlmIChvdGhlckZyb20gIT09IG90aGVyVG8pIHtcbiAgICAgICAgICAvLyBpZiBvdGhlckZyb20gPT0gb3RoZXJUbywgd2UgZG9uJ3QgbmVlZCB0byBjaGFuZ2Ugb3VyIG9wLlxuXG4gICAgICAgICAgLy8gd2hlcmUgZGlkIG15IHRoaW5nIGdvP1xuICAgICAgICAgIGlmIChmcm9tID09PSBvdGhlckZyb20pIHtcbiAgICAgICAgICAgIC8vIHRoZXkgbW92ZWQgaXQhIHRpZSBicmVhay5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgYy5wW2NvbW1vbl0gPSBvdGhlclRvO1xuICAgICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIC8vIHVnaFxuICAgICAgICAgICAgICAgIGMubG0gPSBvdGhlclRvO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoZXkgbW92ZWQgYXJvdW5kIGl0XG4gICAgICAgICAgICBpZiAoZnJvbSA+IG90aGVyRnJvbSkgYy5wW2NvbW1vbl0tLTtcbiAgICAgICAgICAgIGlmIChmcm9tID4gb3RoZXJUbykgYy5wW2NvbW1vbl0rKztcbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb20gPT09IG90aGVyVG8pIHtcbiAgICAgICAgICAgICAgaWYgKG90aGVyRnJvbSA+IG90aGVyVG8pIHtcbiAgICAgICAgICAgICAgICBjLnBbY29tbW9uXSsrO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09PSB0bykgLy8gdWdoLCBhZ2FpblxuICAgICAgICAgICAgICAgICAgYy5sbSsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN0ZXAgMjogd2hlcmUgYW0gaSBnb2luZyB0byBwdXQgaXQ/XG4gICAgICAgICAgICBpZiAodG8gPiBvdGhlckZyb20pIHtcbiAgICAgICAgICAgICAgYy5sbS0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0byA9PT0gb3RoZXJGcm9tKSB7XG4gICAgICAgICAgICAgIGlmICh0byA+IGZyb20pXG4gICAgICAgICAgICAgICAgYy5sbS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvID4gb3RoZXJUbykge1xuICAgICAgICAgICAgICBjLmxtKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvID09PSBvdGhlclRvKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGJvdGggbW92aW5nIGluIHRoZSBzYW1lIGRpcmVjdGlvbiwgdGllIGJyZWFrXG4gICAgICAgICAgICAgIGlmICgob3RoZXJUbyA+IG90aGVyRnJvbSAmJiB0byA+IGZyb20pIHx8XG4gICAgICAgICAgICAgICAgICAob3RoZXJUbyA8IG90aGVyRnJvbSAmJiB0byA8IGZyb20pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdyaWdodCcpIGMubG0rKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodG8gPiBmcm9tKSBjLmxtKys7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG8gPT09IG90aGVyRnJvbSkgYy5sbS0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGMubGkgIT09IHZvaWQgMCAmJiBjLmxkID09PSB1bmRlZmluZWQgJiYgY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAvLyBsaVxuICAgICAgICB2YXIgZnJvbSA9IG90aGVyQy5wW2NvbW1vbl07XG4gICAgICAgIHZhciB0byA9IG90aGVyQy5sbTtcbiAgICAgICAgcCA9IGMucFtjb21tb25dO1xuICAgICAgICBpZiAocCA+IGZyb20pIGMucFtjb21tb25dLS07XG4gICAgICAgIGlmIChwID4gdG8pIGMucFtjb21tb25dKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsZCwgbGQrbGksIHNpLCBzZCwgbmEsIG9pLCBvZCwgb2krb2QsIGFueSBsaSBvbiBhbiBlbGVtZW50IGJlbmVhdGhcbiAgICAgICAgLy8gdGhlIGxtXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGkuZS4gdGhpbmdzIGNhcmUgYWJvdXQgd2hlcmUgdGhlaXIgaXRlbSBpcyBhZnRlciB0aGUgbW92ZS5cbiAgICAgICAgdmFyIGZyb20gPSBvdGhlckMucFtjb21tb25dO1xuICAgICAgICB2YXIgdG8gPSBvdGhlckMubG07XG4gICAgICAgIHAgPSBjLnBbY29tbW9uXTtcbiAgICAgICAgaWYgKHAgPT09IGZyb20pIHtcbiAgICAgICAgICBjLnBbY29tbW9uXSA9IHRvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwID4gZnJvbSkgYy5wW2NvbW1vbl0tLTtcbiAgICAgICAgICBpZiAocCA+IHRvKSBjLnBbY29tbW9uXSsrO1xuICAgICAgICAgIGVsc2UgaWYgKHAgPT09IHRvICYmIGZyb20gPiB0bykgYy5wW2NvbW1vbl0rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvdGhlckMub2kgIT09IHZvaWQgMCAmJiBvdGhlckMub2QgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMucFtjb21tb25dID09PSBvdGhlckMucFtjb21tb25dKSB7XG4gICAgICAgIGlmIChjLm9pICE9PSB2b2lkIDAgJiYgY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAgIC8vIHdlIGluc2VydGVkIHdoZXJlIHNvbWVvbmUgZWxzZSByZXBsYWNlZFxuICAgICAgICAgIGlmICh0eXBlID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAvLyBsZWZ0IHdpbnNcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSB3aW4sIG1ha2Ugb3VyIG9wIHJlcGxhY2Ugd2hhdCB0aGV5IGluc2VydGVkXG4gICAgICAgICAgICBjLm9kID0gb3RoZXJDLm9pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAtPiBub29wIGlmIHRoZSBvdGhlciBjb21wb25lbnQgaXMgZGVsZXRpbmcgdGhlIHNhbWUgb2JqZWN0IChvciBhbnkgcGFyZW50KVxuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvdGhlckMub2kgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMub2kgIT09IHZvaWQgMCAmJiBjLnBbY29tbW9uXSA9PT0gb3RoZXJDLnBbY29tbW9uXSkge1xuICAgICAgICAvLyBsZWZ0IHdpbnMgaWYgd2UgdHJ5IHRvIGluc2VydCBhdCB0aGUgc2FtZSBwbGFjZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAganNvbi5hcHBlbmQoZGVzdCx7cDogYy5wLCBvZDpvdGhlckMub2l9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXJDLm9kICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLnBbY29tbW9uXSA9PSBvdGhlckMucFtjb21tb25dKSB7XG4gICAgICAgIGlmICghY29tbW9uT3BlcmFuZClcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgaWYgKGMub2kgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGRlbGV0ZSBjLm9kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAganNvbi5hcHBlbmQoZGVzdCxjKTtcbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5yZXF1aXJlKCcuL2Jvb3RzdHJhcFRyYW5zZm9ybScpKGpzb24sIGpzb24udHJhbnNmb3JtQ29tcG9uZW50LCBqc29uLmNoZWNrVmFsaWRPcCwganNvbi5hcHBlbmQpO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgc3VidHlwZSBmb3Igc3RyaW5nIG9wZXJhdGlvbnMsIHVzaW5nIHRoZSB0ZXh0MCB0eXBlLlxuICovXG52YXIgdGV4dCA9IHJlcXVpcmUoJy4vdGV4dDAnKTtcblxuanNvbi5yZWdpc3RlclN1YnR5cGUodGV4dCk7XG5tb2R1bGUuZXhwb3J0cyA9IGpzb247XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ot-json0/lib/json0.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ot-json0/lib/text0.js":
/*!********************************************!*\
  !*** ./node_modules/ot-json0/lib/text0.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// DEPRECATED!\n//\n// This type works, but is not exported. Its included here because the JSON0\n// embedded string operations use this library.\n\n\n// A simple text implementation\n//\n// Operations are lists of components. Each component either inserts or deletes\n// at a specified position in the document.\n//\n// Components are either:\n//  {i:'str', p:100}: Insert 'str' at position 100 in the document\n//  {d:'str', p:100}: Delete 'str' at position 100 in the document\n//\n// Components in an operation are executed sequentially, so the position of components\n// assumes previous components have already executed.\n//\n// Eg: This op:\n//   [{i:'abc', p:0}]\n// is equivalent to this op:\n//   [{i:'a', p:0}, {i:'b', p:1}, {i:'c', p:2}]\n\nvar text = module.exports = {\n  name: 'text0',\n  uri: 'http://sharejs.org/types/textv0',\n  create: function(initial) {\n    if ((initial != null) && typeof initial !== 'string') {\n      throw new Error('Initial data must be a string');\n    }\n    return initial || '';\n  }\n};\n\n/** Insert s2 into s1 at pos. */\nvar strInject = function(s1, pos, s2) {\n  return s1.slice(0, pos) + s2 + s1.slice(pos);\n};\n\n/** Check that an operation component is valid. Throws if its invalid. */\nvar checkValidComponent = function(c) {\n  if (typeof c.p !== 'number')\n    throw new Error('component missing position field');\n\n  if ((typeof c.i === 'string') === (typeof c.d === 'string'))\n    throw new Error('component needs an i or d field');\n\n  if (c.p < 0)\n    throw new Error('position cannot be negative');\n};\n\n/** Check that an operation is valid */\nvar checkValidOp = function(op) {\n  for (var i = 0; i < op.length; i++) {\n    checkValidComponent(op[i]);\n  }\n};\n\n/** Apply op to snapshot */\ntext.apply = function(snapshot, op) {\n  var deleted;\n\n  checkValidOp(op);\n  for (var i = 0; i < op.length; i++) {\n    var component = op[i];\n    if (component.i != null) {\n      snapshot = strInject(snapshot, component.p, component.i);\n    } else {\n      deleted = snapshot.slice(component.p, component.p + component.d.length);\n      if (component.d !== deleted)\n        throw new Error(\"Delete component '\" + component.d + \"' does not match deleted text '\" + deleted + \"'\");\n\n      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);\n    }\n  }\n  return snapshot;\n};\n\n/**\n * Append a component to the end of newOp. Exported for use by the random op\n * generator and the JSON0 type.\n */\nvar append = text._append = function(newOp, c) {\n  if (c.i === '' || c.d === '') return;\n\n  if (newOp.length === 0) {\n    newOp.push(c);\n  } else {\n    var last = newOp[newOp.length - 1];\n\n    if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {\n      // Compose the insert into the previous insert\n      newOp[newOp.length - 1] = {i:strInject(last.i, c.p - last.p, c.i), p:last.p};\n\n    } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {\n      // Compose the deletes together\n      newOp[newOp.length - 1] = {d:strInject(c.d, last.p - c.p, last.d), p:c.p};\n\n    } else {\n      newOp.push(c);\n    }\n  }\n};\n\n/** Compose op1 and op2 together */\ntext.compose = function(op1, op2) {\n  checkValidOp(op1);\n  checkValidOp(op2);\n  var newOp = op1.slice();\n  for (var i = 0; i < op2.length; i++) {\n    append(newOp, op2[i]);\n  }\n  return newOp;\n};\n\n/** Clean up an op */\ntext.normalize = function(op) {\n  var newOp = [];\n\n  // Normalize should allow ops which are a single (unwrapped) component:\n  // {i:'asdf', p:23}.\n  // There's no good way to test if something is an array:\n  // http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  // so this is probably the least bad solution.\n  if (op.i != null || op.p != null) op = [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = 0;\n\n    append(newOp, c);\n  }\n\n  return newOp;\n};\n\n// This helper method transforms a position by an op component.\n//\n// If c is an insert, insertAfter specifies whether the transform\n// is pushed after the insert (true) or before it (false).\n//\n// insertAfter is optional for deletes.\nvar transformPosition = function(pos, c, insertAfter) {\n  // This will get collapsed into a giant ternary by uglify.\n  if (c.i != null) {\n    if (c.p < pos || (c.p === pos && insertAfter)) {\n      return pos + c.i.length;\n    } else {\n      return pos;\n    }\n  } else {\n    // I think this could also be written as: Math.min(c.p, Math.min(c.p -\n    // otherC.p, otherC.d.length)) but I think its harder to read that way, and\n    // it compiles using ternary operators anyway so its no slower written like\n    // this.\n    if (pos <= c.p) {\n      return pos;\n    } else if (pos <= c.p + c.d.length) {\n      return c.p;\n    } else {\n      return pos - c.d.length;\n    }\n  }\n};\n\n// Helper method to transform a cursor position as a result of an op.\n//\n// Like transformPosition above, if c is an insert, insertAfter specifies\n// whether the cursor position is pushed after an insert (true) or before it\n// (false).\ntext.transformCursor = function(position, op, side) {\n  var insertAfter = side === 'right';\n  for (var i = 0; i < op.length; i++) {\n    position = transformPosition(position, op[i], insertAfter);\n  }\n\n  return position;\n};\n\n// Transform an op component by another op component. Asymmetric.\n// The result will be appended to destination.\n//\n// exported for use in JSON type\nvar transformComponent = text._tc = function(dest, c, otherC, side) {\n  //var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;\n\n  checkValidComponent(c);\n  checkValidComponent(otherC);\n\n  if (c.i != null) {\n    // Insert.\n    append(dest, {i:c.i, p:transformPosition(c.p, otherC, side === 'right')});\n  } else {\n    // Delete\n    if (otherC.i != null) {\n      // Delete vs insert\n      var s = c.d;\n      if (c.p < otherC.p) {\n        append(dest, {d:s.slice(0, otherC.p - c.p), p:c.p});\n        s = s.slice(otherC.p - c.p);\n      }\n      if (s !== '')\n        append(dest, {d: s, p: c.p + otherC.i.length});\n\n    } else {\n      // Delete vs delete\n      if (c.p >= otherC.p + otherC.d.length)\n        append(dest, {d: c.d, p: c.p - otherC.d.length});\n      else if (c.p + c.d.length <= otherC.p)\n        append(dest, c);\n      else {\n        // They overlap somewhere.\n        var newC = {d: '', p: c.p};\n\n        if (c.p < otherC.p)\n          newC.d = c.d.slice(0, otherC.p - c.p);\n\n        if (c.p + c.d.length > otherC.p + otherC.d.length)\n          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);\n\n        // This is entirely optional - I'm just checking the deleted text in\n        // the two ops matches\n        var intersectStart = Math.max(c.p, otherC.p);\n        var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);\n        var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);\n        var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);\n        if (cIntersect !== otherIntersect)\n          throw new Error('Delete ops delete different text in the same region of the document');\n\n        if (newC.d !== '') {\n          newC.p = transformPosition(newC.p, otherC);\n          append(dest, newC);\n        }\n      }\n    }\n  }\n\n  return dest;\n};\n\nvar invertComponent = function(c) {\n  return (c.i != null) ? {d:c.i, p:c.p} : {i:c.d, p:c.p};\n};\n\n// No need to use append for invert, because the components won't be able to\n// cancel one another.\ntext.invert = function(op) {\n  // Shallow copy & reverse that sucka.\n  op = op.slice().reverse();\n  for (var i = 0; i < op.length; i++) {\n    op[i] = invertComponent(op[i]);\n  }\n  return op;\n};\n\n__webpack_require__(/*! ./bootstrapTransform */ \"(ssr)/./node_modules/ot-json0/lib/bootstrapTransform.js\")(text, transformComponent, checkValidOp, append);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3QtanNvbjAvbGliL3RleHQwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGVBQWU7QUFDcEIsS0FBSyxlQUFlO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGFBQWE7QUFDcEI7QUFDQSxPQUFPLFdBQVcsR0FBRyxXQUFXLEdBQUcsV0FBVzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakMsTUFBTTtBQUNOO0FBQ0EsaUNBQWlDOztBQUVqQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxlQUFlO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQiwwREFBMEQ7QUFDNUUsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7O0FBRXJELE1BQU07QUFDTjtBQUNBO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixjQUFjLEdBQUc7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFPLENBQUMscUZBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGF5OV9jb2xsYWJvcmF0aXZlX2VkaXRvci8uL25vZGVfbW9kdWxlcy9vdC1qc29uMC9saWIvdGV4dDAuanM/ODkxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBERVBSRUNBVEVEIVxuLy9cbi8vIFRoaXMgdHlwZSB3b3JrcywgYnV0IGlzIG5vdCBleHBvcnRlZC4gSXRzIGluY2x1ZGVkIGhlcmUgYmVjYXVzZSB0aGUgSlNPTjBcbi8vIGVtYmVkZGVkIHN0cmluZyBvcGVyYXRpb25zIHVzZSB0aGlzIGxpYnJhcnkuXG5cblxuLy8gQSBzaW1wbGUgdGV4dCBpbXBsZW1lbnRhdGlvblxuLy9cbi8vIE9wZXJhdGlvbnMgYXJlIGxpc3RzIG9mIGNvbXBvbmVudHMuIEVhY2ggY29tcG9uZW50IGVpdGhlciBpbnNlcnRzIG9yIGRlbGV0ZXNcbi8vIGF0IGEgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudC5cbi8vXG4vLyBDb21wb25lbnRzIGFyZSBlaXRoZXI6XG4vLyAge2k6J3N0cicsIHA6MTAwfTogSW5zZXJ0ICdzdHInIGF0IHBvc2l0aW9uIDEwMCBpbiB0aGUgZG9jdW1lbnRcbi8vICB7ZDonc3RyJywgcDoxMDB9OiBEZWxldGUgJ3N0cicgYXQgcG9zaXRpb24gMTAwIGluIHRoZSBkb2N1bWVudFxuLy9cbi8vIENvbXBvbmVudHMgaW4gYW4gb3BlcmF0aW9uIGFyZSBleGVjdXRlZCBzZXF1ZW50aWFsbHksIHNvIHRoZSBwb3NpdGlvbiBvZiBjb21wb25lbnRzXG4vLyBhc3N1bWVzIHByZXZpb3VzIGNvbXBvbmVudHMgaGF2ZSBhbHJlYWR5IGV4ZWN1dGVkLlxuLy9cbi8vIEVnOiBUaGlzIG9wOlxuLy8gICBbe2k6J2FiYycsIHA6MH1dXG4vLyBpcyBlcXVpdmFsZW50IHRvIHRoaXMgb3A6XG4vLyAgIFt7aTonYScsIHA6MH0sIHtpOidiJywgcDoxfSwge2k6J2MnLCBwOjJ9XVxuXG52YXIgdGV4dCA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lOiAndGV4dDAnLFxuICB1cmk6ICdodHRwOi8vc2hhcmVqcy5vcmcvdHlwZXMvdGV4dHYwJyxcbiAgY3JlYXRlOiBmdW5jdGlvbihpbml0aWFsKSB7XG4gICAgaWYgKChpbml0aWFsICE9IG51bGwpICYmIHR5cGVvZiBpbml0aWFsICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbml0aWFsIGRhdGEgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdGlhbCB8fCAnJztcbiAgfVxufTtcblxuLyoqIEluc2VydCBzMiBpbnRvIHMxIGF0IHBvcy4gKi9cbnZhciBzdHJJbmplY3QgPSBmdW5jdGlvbihzMSwgcG9zLCBzMikge1xuICByZXR1cm4gczEuc2xpY2UoMCwgcG9zKSArIHMyICsgczEuc2xpY2UocG9zKTtcbn07XG5cbi8qKiBDaGVjayB0aGF0IGFuIG9wZXJhdGlvbiBjb21wb25lbnQgaXMgdmFsaWQuIFRocm93cyBpZiBpdHMgaW52YWxpZC4gKi9cbnZhciBjaGVja1ZhbGlkQ29tcG9uZW50ID0gZnVuY3Rpb24oYykge1xuICBpZiAodHlwZW9mIGMucCAhPT0gJ251bWJlcicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21wb25lbnQgbWlzc2luZyBwb3NpdGlvbiBmaWVsZCcpO1xuXG4gIGlmICgodHlwZW9mIGMuaSA9PT0gJ3N0cmluZycpID09PSAodHlwZW9mIGMuZCA9PT0gJ3N0cmluZycpKVxuICAgIHRocm93IG5ldyBFcnJvcignY29tcG9uZW50IG5lZWRzIGFuIGkgb3IgZCBmaWVsZCcpO1xuXG4gIGlmIChjLnAgPCAwKVxuICAgIHRocm93IG5ldyBFcnJvcigncG9zaXRpb24gY2Fubm90IGJlIG5lZ2F0aXZlJyk7XG59O1xuXG4vKiogQ2hlY2sgdGhhdCBhbiBvcGVyYXRpb24gaXMgdmFsaWQgKi9cbnZhciBjaGVja1ZhbGlkT3AgPSBmdW5jdGlvbihvcCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hlY2tWYWxpZENvbXBvbmVudChvcFtpXSk7XG4gIH1cbn07XG5cbi8qKiBBcHBseSBvcCB0byBzbmFwc2hvdCAqL1xudGV4dC5hcHBseSA9IGZ1bmN0aW9uKHNuYXBzaG90LCBvcCkge1xuICB2YXIgZGVsZXRlZDtcblxuICBjaGVja1ZhbGlkT3Aob3ApO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IG9wW2ldO1xuICAgIGlmIChjb21wb25lbnQuaSAhPSBudWxsKSB7XG4gICAgICBzbmFwc2hvdCA9IHN0ckluamVjdChzbmFwc2hvdCwgY29tcG9uZW50LnAsIGNvbXBvbmVudC5pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlZCA9IHNuYXBzaG90LnNsaWNlKGNvbXBvbmVudC5wLCBjb21wb25lbnQucCArIGNvbXBvbmVudC5kLmxlbmd0aCk7XG4gICAgICBpZiAoY29tcG9uZW50LmQgIT09IGRlbGV0ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlbGV0ZSBjb21wb25lbnQgJ1wiICsgY29tcG9uZW50LmQgKyBcIicgZG9lcyBub3QgbWF0Y2ggZGVsZXRlZCB0ZXh0ICdcIiArIGRlbGV0ZWQgKyBcIidcIik7XG5cbiAgICAgIHNuYXBzaG90ID0gc25hcHNob3Quc2xpY2UoMCwgY29tcG9uZW50LnApICsgc25hcHNob3Quc2xpY2UoY29tcG9uZW50LnAgKyBjb21wb25lbnQuZC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc25hcHNob3Q7XG59O1xuXG4vKipcbiAqIEFwcGVuZCBhIGNvbXBvbmVudCB0byB0aGUgZW5kIG9mIG5ld09wLiBFeHBvcnRlZCBmb3IgdXNlIGJ5IHRoZSByYW5kb20gb3BcbiAqIGdlbmVyYXRvciBhbmQgdGhlIEpTT04wIHR5cGUuXG4gKi9cbnZhciBhcHBlbmQgPSB0ZXh0Ll9hcHBlbmQgPSBmdW5jdGlvbihuZXdPcCwgYykge1xuICBpZiAoYy5pID09PSAnJyB8fCBjLmQgPT09ICcnKSByZXR1cm47XG5cbiAgaWYgKG5ld09wLmxlbmd0aCA9PT0gMCkge1xuICAgIG5ld09wLnB1c2goYyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxhc3QgPSBuZXdPcFtuZXdPcC5sZW5ndGggLSAxXTtcblxuICAgIGlmIChsYXN0LmkgIT0gbnVsbCAmJiBjLmkgIT0gbnVsbCAmJiBsYXN0LnAgPD0gYy5wICYmIGMucCA8PSBsYXN0LnAgKyBsYXN0LmkubGVuZ3RoKSB7XG4gICAgICAvLyBDb21wb3NlIHRoZSBpbnNlcnQgaW50byB0aGUgcHJldmlvdXMgaW5zZXJ0XG4gICAgICBuZXdPcFtuZXdPcC5sZW5ndGggLSAxXSA9IHtpOnN0ckluamVjdChsYXN0LmksIGMucCAtIGxhc3QucCwgYy5pKSwgcDpsYXN0LnB9O1xuXG4gICAgfSBlbHNlIGlmIChsYXN0LmQgIT0gbnVsbCAmJiBjLmQgIT0gbnVsbCAmJiBjLnAgPD0gbGFzdC5wICYmIGxhc3QucCA8PSBjLnAgKyBjLmQubGVuZ3RoKSB7XG4gICAgICAvLyBDb21wb3NlIHRoZSBkZWxldGVzIHRvZ2V0aGVyXG4gICAgICBuZXdPcFtuZXdPcC5sZW5ndGggLSAxXSA9IHtkOnN0ckluamVjdChjLmQsIGxhc3QucCAtIGMucCwgbGFzdC5kKSwgcDpjLnB9O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld09wLnB1c2goYyk7XG4gICAgfVxuICB9XG59O1xuXG4vKiogQ29tcG9zZSBvcDEgYW5kIG9wMiB0b2dldGhlciAqL1xudGV4dC5jb21wb3NlID0gZnVuY3Rpb24ob3AxLCBvcDIpIHtcbiAgY2hlY2tWYWxpZE9wKG9wMSk7XG4gIGNoZWNrVmFsaWRPcChvcDIpO1xuICB2YXIgbmV3T3AgPSBvcDEuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcDIubGVuZ3RoOyBpKyspIHtcbiAgICBhcHBlbmQobmV3T3AsIG9wMltpXSk7XG4gIH1cbiAgcmV0dXJuIG5ld09wO1xufTtcblxuLyoqIENsZWFuIHVwIGFuIG9wICovXG50ZXh0Lm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG9wKSB7XG4gIHZhciBuZXdPcCA9IFtdO1xuXG4gIC8vIE5vcm1hbGl6ZSBzaG91bGQgYWxsb3cgb3BzIHdoaWNoIGFyZSBhIHNpbmdsZSAodW53cmFwcGVkKSBjb21wb25lbnQ6XG4gIC8vIHtpOidhc2RmJywgcDoyM30uXG4gIC8vIFRoZXJlJ3Mgbm8gZ29vZCB3YXkgdG8gdGVzdCBpZiBzb21ldGhpbmcgaXMgYW4gYXJyYXk6XG4gIC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2luc3RhbmNlb2YtY29uc2lkZXJlZC1oYXJtZnVsLW9yLWhvdy10by13cml0ZS1hLXJvYnVzdC1pc2FycmF5L1xuICAvLyBzbyB0aGlzIGlzIHByb2JhYmx5IHRoZSBsZWFzdCBiYWQgc29sdXRpb24uXG4gIGlmIChvcC5pICE9IG51bGwgfHwgb3AucCAhPSBudWxsKSBvcCA9IFtvcF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gb3BbaV07XG4gICAgaWYgKGMucCA9PSBudWxsKSBjLnAgPSAwO1xuXG4gICAgYXBwZW5kKG5ld09wLCBjKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPcDtcbn07XG5cbi8vIFRoaXMgaGVscGVyIG1ldGhvZCB0cmFuc2Zvcm1zIGEgcG9zaXRpb24gYnkgYW4gb3AgY29tcG9uZW50LlxuLy9cbi8vIElmIGMgaXMgYW4gaW5zZXJ0LCBpbnNlcnRBZnRlciBzcGVjaWZpZXMgd2hldGhlciB0aGUgdHJhbnNmb3JtXG4vLyBpcyBwdXNoZWQgYWZ0ZXIgdGhlIGluc2VydCAodHJ1ZSkgb3IgYmVmb3JlIGl0IChmYWxzZSkuXG4vL1xuLy8gaW5zZXJ0QWZ0ZXIgaXMgb3B0aW9uYWwgZm9yIGRlbGV0ZXMuXG52YXIgdHJhbnNmb3JtUG9zaXRpb24gPSBmdW5jdGlvbihwb3MsIGMsIGluc2VydEFmdGVyKSB7XG4gIC8vIFRoaXMgd2lsbCBnZXQgY29sbGFwc2VkIGludG8gYSBnaWFudCB0ZXJuYXJ5IGJ5IHVnbGlmeS5cbiAgaWYgKGMuaSAhPSBudWxsKSB7XG4gICAgaWYgKGMucCA8IHBvcyB8fCAoYy5wID09PSBwb3MgJiYgaW5zZXJ0QWZ0ZXIpKSB7XG4gICAgICByZXR1cm4gcG9zICsgYy5pLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSSB0aGluayB0aGlzIGNvdWxkIGFsc28gYmUgd3JpdHRlbiBhczogTWF0aC5taW4oYy5wLCBNYXRoLm1pbihjLnAgLVxuICAgIC8vIG90aGVyQy5wLCBvdGhlckMuZC5sZW5ndGgpKSBidXQgSSB0aGluayBpdHMgaGFyZGVyIHRvIHJlYWQgdGhhdCB3YXksIGFuZFxuICAgIC8vIGl0IGNvbXBpbGVzIHVzaW5nIHRlcm5hcnkgb3BlcmF0b3JzIGFueXdheSBzbyBpdHMgbm8gc2xvd2VyIHdyaXR0ZW4gbGlrZVxuICAgIC8vIHRoaXMuXG4gICAgaWYgKHBvcyA8PSBjLnApIHtcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfSBlbHNlIGlmIChwb3MgPD0gYy5wICsgYy5kLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGMucDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBvcyAtIGMuZC5sZW5ndGg7XG4gICAgfVxuICB9XG59O1xuXG4vLyBIZWxwZXIgbWV0aG9kIHRvIHRyYW5zZm9ybSBhIGN1cnNvciBwb3NpdGlvbiBhcyBhIHJlc3VsdCBvZiBhbiBvcC5cbi8vXG4vLyBMaWtlIHRyYW5zZm9ybVBvc2l0aW9uIGFib3ZlLCBpZiBjIGlzIGFuIGluc2VydCwgaW5zZXJ0QWZ0ZXIgc3BlY2lmaWVzXG4vLyB3aGV0aGVyIHRoZSBjdXJzb3IgcG9zaXRpb24gaXMgcHVzaGVkIGFmdGVyIGFuIGluc2VydCAodHJ1ZSkgb3IgYmVmb3JlIGl0XG4vLyAoZmFsc2UpLlxudGV4dC50cmFuc2Zvcm1DdXJzb3IgPSBmdW5jdGlvbihwb3NpdGlvbiwgb3AsIHNpZGUpIHtcbiAgdmFyIGluc2VydEFmdGVyID0gc2lkZSA9PT0gJ3JpZ2h0JztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHBvc2l0aW9uID0gdHJhbnNmb3JtUG9zaXRpb24ocG9zaXRpb24sIG9wW2ldLCBpbnNlcnRBZnRlcik7XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb247XG59O1xuXG4vLyBUcmFuc2Zvcm0gYW4gb3AgY29tcG9uZW50IGJ5IGFub3RoZXIgb3AgY29tcG9uZW50LiBBc3ltbWV0cmljLlxuLy8gVGhlIHJlc3VsdCB3aWxsIGJlIGFwcGVuZGVkIHRvIGRlc3RpbmF0aW9uLlxuLy9cbi8vIGV4cG9ydGVkIGZvciB1c2UgaW4gSlNPTiB0eXBlXG52YXIgdHJhbnNmb3JtQ29tcG9uZW50ID0gdGV4dC5fdGMgPSBmdW5jdGlvbihkZXN0LCBjLCBvdGhlckMsIHNpZGUpIHtcbiAgLy92YXIgY0ludGVyc2VjdCwgaW50ZXJzZWN0RW5kLCBpbnRlcnNlY3RTdGFydCwgbmV3Qywgb3RoZXJJbnRlcnNlY3QsIHM7XG5cbiAgY2hlY2tWYWxpZENvbXBvbmVudChjKTtcbiAgY2hlY2tWYWxpZENvbXBvbmVudChvdGhlckMpO1xuXG4gIGlmIChjLmkgIT0gbnVsbCkge1xuICAgIC8vIEluc2VydC5cbiAgICBhcHBlbmQoZGVzdCwge2k6Yy5pLCBwOnRyYW5zZm9ybVBvc2l0aW9uKGMucCwgb3RoZXJDLCBzaWRlID09PSAncmlnaHQnKX0pO1xuICB9IGVsc2Uge1xuICAgIC8vIERlbGV0ZVxuICAgIGlmIChvdGhlckMuaSAhPSBudWxsKSB7XG4gICAgICAvLyBEZWxldGUgdnMgaW5zZXJ0XG4gICAgICB2YXIgcyA9IGMuZDtcbiAgICAgIGlmIChjLnAgPCBvdGhlckMucCkge1xuICAgICAgICBhcHBlbmQoZGVzdCwge2Q6cy5zbGljZSgwLCBvdGhlckMucCAtIGMucCksIHA6Yy5wfSk7XG4gICAgICAgIHMgPSBzLnNsaWNlKG90aGVyQy5wIC0gYy5wKTtcbiAgICAgIH1cbiAgICAgIGlmIChzICE9PSAnJylcbiAgICAgICAgYXBwZW5kKGRlc3QsIHtkOiBzLCBwOiBjLnAgKyBvdGhlckMuaS5sZW5ndGh9KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWxldGUgdnMgZGVsZXRlXG4gICAgICBpZiAoYy5wID49IG90aGVyQy5wICsgb3RoZXJDLmQubGVuZ3RoKVxuICAgICAgICBhcHBlbmQoZGVzdCwge2Q6IGMuZCwgcDogYy5wIC0gb3RoZXJDLmQubGVuZ3RofSk7XG4gICAgICBlbHNlIGlmIChjLnAgKyBjLmQubGVuZ3RoIDw9IG90aGVyQy5wKVxuICAgICAgICBhcHBlbmQoZGVzdCwgYyk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gVGhleSBvdmVybGFwIHNvbWV3aGVyZS5cbiAgICAgICAgdmFyIG5ld0MgPSB7ZDogJycsIHA6IGMucH07XG5cbiAgICAgICAgaWYgKGMucCA8IG90aGVyQy5wKVxuICAgICAgICAgIG5ld0MuZCA9IGMuZC5zbGljZSgwLCBvdGhlckMucCAtIGMucCk7XG5cbiAgICAgICAgaWYgKGMucCArIGMuZC5sZW5ndGggPiBvdGhlckMucCArIG90aGVyQy5kLmxlbmd0aClcbiAgICAgICAgICBuZXdDLmQgKz0gYy5kLnNsaWNlKG90aGVyQy5wICsgb3RoZXJDLmQubGVuZ3RoIC0gYy5wKTtcblxuICAgICAgICAvLyBUaGlzIGlzIGVudGlyZWx5IG9wdGlvbmFsIC0gSSdtIGp1c3QgY2hlY2tpbmcgdGhlIGRlbGV0ZWQgdGV4dCBpblxuICAgICAgICAvLyB0aGUgdHdvIG9wcyBtYXRjaGVzXG4gICAgICAgIHZhciBpbnRlcnNlY3RTdGFydCA9IE1hdGgubWF4KGMucCwgb3RoZXJDLnApO1xuICAgICAgICB2YXIgaW50ZXJzZWN0RW5kID0gTWF0aC5taW4oYy5wICsgYy5kLmxlbmd0aCwgb3RoZXJDLnAgKyBvdGhlckMuZC5sZW5ndGgpO1xuICAgICAgICB2YXIgY0ludGVyc2VjdCA9IGMuZC5zbGljZShpbnRlcnNlY3RTdGFydCAtIGMucCwgaW50ZXJzZWN0RW5kIC0gYy5wKTtcbiAgICAgICAgdmFyIG90aGVySW50ZXJzZWN0ID0gb3RoZXJDLmQuc2xpY2UoaW50ZXJzZWN0U3RhcnQgLSBvdGhlckMucCwgaW50ZXJzZWN0RW5kIC0gb3RoZXJDLnApO1xuICAgICAgICBpZiAoY0ludGVyc2VjdCAhPT0gb3RoZXJJbnRlcnNlY3QpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWxldGUgb3BzIGRlbGV0ZSBkaWZmZXJlbnQgdGV4dCBpbiB0aGUgc2FtZSByZWdpb24gb2YgdGhlIGRvY3VtZW50Jyk7XG5cbiAgICAgICAgaWYgKG5ld0MuZCAhPT0gJycpIHtcbiAgICAgICAgICBuZXdDLnAgPSB0cmFuc2Zvcm1Qb3NpdGlvbihuZXdDLnAsIG90aGVyQyk7XG4gICAgICAgICAgYXBwZW5kKGRlc3QsIG5ld0MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG52YXIgaW52ZXJ0Q29tcG9uZW50ID0gZnVuY3Rpb24oYykge1xuICByZXR1cm4gKGMuaSAhPSBudWxsKSA/IHtkOmMuaSwgcDpjLnB9IDoge2k6Yy5kLCBwOmMucH07XG59O1xuXG4vLyBObyBuZWVkIHRvIHVzZSBhcHBlbmQgZm9yIGludmVydCwgYmVjYXVzZSB0aGUgY29tcG9uZW50cyB3b24ndCBiZSBhYmxlIHRvXG4vLyBjYW5jZWwgb25lIGFub3RoZXIuXG50ZXh0LmludmVydCA9IGZ1bmN0aW9uKG9wKSB7XG4gIC8vIFNoYWxsb3cgY29weSAmIHJldmVyc2UgdGhhdCBzdWNrYS5cbiAgb3AgPSBvcC5zbGljZSgpLnJldmVyc2UoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIG9wW2ldID0gaW52ZXJ0Q29tcG9uZW50KG9wW2ldKTtcbiAgfVxuICByZXR1cm4gb3A7XG59O1xuXG5yZXF1aXJlKCcuL2Jvb3RzdHJhcFRyYW5zZm9ybScpKHRleHQsIHRyYW5zZm9ybUNvbXBvbmVudCwgY2hlY2tWYWxpZE9wLCBhcHBlbmQpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ot-json0/lib/text0.js\n");

/***/ })

};
;